import CasePaths
import Clocks
import Combine
import CombineSchedulers
import ConcurrencyExtras
import CustomDump
import Dependencies
import DependenciesMacros
import Dispatch
import Foundation
import class Foundation.Bundle
import class Foundation.ProcessInfo
import struct Foundation.URL
import IdentifiedCollections
import IssueReporting
import OSLog
import Observation
import OrderedCollections
import Perception
import Sharing
import SwiftUI
import SwiftUINavigation
import UIKit
import UIKitNavigation

public struct AnyIdentifiable : Identifiable {

    /// The stable identity of the entity associated with this instance.
    public let id: AnyHashable

    public init<Base>(_ base: Base) where Base : Identifiable
}

/// A type defining a user defaults persistence strategy via key path.
///
/// See ``Sharing/SharedReaderKey/appStorage(_:)`` to create values of this type.
@available(*, deprecated, message: "Use an 'AppStorageKey', instead")
public struct AppStorageKeyPathKey<Value> : Sendable where Value : Sendable {

    public init(_ keyPath: ComposableArchitecture._SendableReferenceWritableKeyPath<UserDefaults, Value>)
}

@available(*, deprecated, message: "Use an 'AppStorageKey', instead")
extension AppStorageKeyPathKey : Sharing.SharedKey, Hashable {

    /// Loads the freshest value from storage.
    ///
    /// - Parameters
    ///   - context: The context of loading a value.
    ///   - continuation: A continuation that can be fed the result of loading a value from an
    ///     external system.
    public func load(context: Sharing.LoadContext<Value>, continuation: Sharing.LoadContinuation<Value>)

    /// Subscribes to external updates.
    ///
    /// - Parameters:
    ///   - context: The context of subscribing to updates.
    ///   - subscriber: A continuation that can be fed new results from an external system, or the
    ///     initial value if the external system no longer holds a value.
    /// - Returns: A subscription to updates from an external system. If it is cancelled or
    ///   deinitialized, `subscriber` will no longer receive updates from the external system.
    public func subscribe(context: Sharing.LoadContext<Value>, subscriber: Sharing.SharedSubscriber<Value>) -> Sharing.SharedSubscription

    /// Saves a value to storage.
    ///
    /// - Parameters:
    ///   - value: The value to save.
    ///   - context: The context of saving a value.
    ///   - continuation: A continuation that should be notified upon the completion of saving a
    ///     shared value.
    public func save(_ value: Value, context: Sharing.SaveContext, continuation: Sharing.SaveContinuation)
}

/// An action type that exposes a `binding` case that holds a ``BindingAction``.
///
/// Used in conjunction with ``BindingState`` to safely eliminate the boilerplate typically
/// associated with mutating multiple fields in state.
///
/// Read <doc:Bindings> for more information.
public protocol BindableAction<State> {

    /// The root state type that contains bindable fields.
    associatedtype State

    /// Embeds a binding action in this action type.
    ///
    /// - Returns: A binding action.
    static func binding(_ action: ComposableArchitecture.BindingAction<Self.State>) -> Self

    /// Extracts a binding action from this action type.
    var binding: ComposableArchitecture.BindingAction<Self.State>? { get }
}

extension BindableAction where Self.State : ComposableArchitecture.ObservableState {

    public static func set<Value>(_ keyPath: ComposableArchitecture._SendableWritableKeyPath<Self.State, Value>, _ value: Value) -> Self where Value : Equatable, Value : Sendable
}

extension BindableAction {

    /// Extracts a binding action from this action type.
    public var binding: ComposableArchitecture.BindingAction<Self.State>? { get }
}

extension BindableAction {

    /// Constructs a binding action for the given key path and bindable value.
    ///
    /// Shorthand for `.binding(.set(\.$keyPath, value))`.
    ///
    /// - Returns: A binding action.
    public static func set<Value>(_ keyPath: ComposableArchitecture._SendableWritableKeyPath<Self.State, ComposableArchitecture.BindingState<Value>>, _ value: Value) -> Self where Value : Equatable, Value : Sendable
}

/// An action that describes simple mutations to some root state at a writable key path.
///
/// Used in conjunction with ``BindingState`` and ``BindableAction`` to safely eliminate the
/// boilerplate typically associated with mutating multiple fields in state.
///
/// Read <doc:Bindings> for more information.
public struct BindingAction<Root> : CasePathsCore.CasePathable, Equatable, Sendable {

    public let keyPath: ComposableArchitecture._SendablePartialKeyPath<Root>

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.BindingAction<Root>, rhs: ComposableArchitecture.BindingAction<Root>) -> Bool

    /// A collection of all case paths of this type.
    public static var allCasePaths: ComposableArchitecture.BindingAction<Root>.AllCasePaths { get }

    /// A type that can represent a collection of all case paths of this type.
    @dynamicMemberLookup public struct AllCasePaths {

        public subscript<Value>(dynamicMember keyPath: WritableKeyPath<Root, Value>) -> CasePathsCore.AnyCasePath<ComposableArchitecture.BindingAction<Root>, Value> where Root : ComposableArchitecture.ObservableState, Value : Equatable, Value : Sendable { get }

        public subscript<Value>(dynamicMember keyPath: WritableKeyPath<Root, ComposableArchitecture.BindingState<Value>>) -> CasePathsCore.AnyCasePath<ComposableArchitecture.BindingAction<Root>, Value> where Value : Equatable, Value : Sendable { get }
    }
}

extension BindingAction {

    public static func set<Value>(_ keyPath: ComposableArchitecture._SendableWritableKeyPath<Root, Value>, _ value: Value) -> ComposableArchitecture.BindingAction<Root> where Root : ComposableArchitecture.ObservableState, Value : Equatable, Value : Sendable

    public static func ~= <Value>(keyPath: WritableKeyPath<Root, Value>, bindingAction: ComposableArchitecture.BindingAction<Root>) -> Bool where Root : ComposableArchitecture.ObservableState
}

extension BindingAction {

    /// Returns an action that describes simple mutations to some root state at a writable key path
    /// to binding state.
    ///
    /// - Parameters:
    ///   - keyPath: A key path to the property that should be mutated. This property must be
    ///     annotated with the ``BindingState`` property wrapper.
    ///   - value: A value to assign at the given key path.
    /// - Returns: An action that describes simple mutations to some root state at a writable key
    ///   path.
    public static func set<Value>(_ keyPath: ComposableArchitecture._SendableWritableKeyPath<Root, ComposableArchitecture.BindingState<Value>>, _ value: Value) -> ComposableArchitecture.BindingAction<Root> where Value : Equatable, Value : Sendable

    /// Matches a binding action by its key path.
    ///
    /// Implicitly invoked when switching on a reducer's action and pattern matching on a binding
    /// action directly to do further work:
    ///
    /// ```swift
    /// case .binding(\.displayName): // Invokes the `~=` operator.
    ///   // Validate display name
    ///
    /// case .binding(\.enableNotifications):
    ///   // Return an authorization request effect
    /// ```
    public static func ~= <Value>(keyPath: WritableKeyPath<Root, ComposableArchitecture.BindingState<Value>>, bindingAction: ComposableArchitecture.BindingAction<Root>) -> Bool
}

extension BindingAction : CustomDump.CustomDumpStringConvertible {

    /// The custom dump description for this instance.
    public var customDumpDescription: String { get }
}

/// A reducer that updates bindable state when it receives binding actions.
///
/// This reducer should typically be composed into the ``Reducer/body-swift.property`` of your
/// feature's reducer:
///
/// ```swift
/// @Reducer
/// struct Feature {
///   struct State {
///     @BindingState var isOn = false
///     // More properties...
///   }
///   enum Action: BindableAction {
///     case binding(BindingAction<State>)
///     // More actions
///   }
///
///   var body: some ReducerOf<Self> {
///     BindingReducer()
///     Reduce { state, action in
///       // Your feature's logic...
///     }
///   }
/// }
/// ```
///
/// This makes it so that the binding's logic is run before the feature's logic, _i.e._ you will
/// only see the state after the binding was written. If you want to react to the state _before_ the
/// binding was written, you can flip the order of the composition:
///
/// ```swift
/// var body: some ReducerOf<Self> {
///   Reduce { state, action in
///     // Your feature's logic...
///   }
///   BindingReducer()
/// }
/// ```
///
/// If you forget to compose the ``BindingReducer`` into your feature's reducer, then when a binding
/// is written to it will cause a runtime purple Xcode warning letting you know what needs to be
/// fixed.
public struct BindingReducer<State, Action, ViewAction> : ComposableArchitecture.Reducer where State == ViewAction.State, ViewAction : ComposableArchitecture.BindableAction {

    /// Initializes a reducer that updates bindable state when it receives binding actions.
    @inlinable public init() where State == Action.State, Action : ComposableArchitecture.BindableAction, Action == ViewAction

    @inlinable public init(action toViewAction: CasePathsCore.CaseKeyPath<Action, ViewAction>) where Action : CasePathsCore.CasePathable

    @inlinable public init(action toViewAction: @escaping (_ action: Action) -> ViewAction?)

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout State, action: Action) -> ComposableArchitecture.Effect<Action>
}

/// A property wrapper type that can designate properties of app state that can be directly bindable
/// in SwiftUI views.
///
/// Along with an action type that conforms to the ``BindableAction`` protocol, this type can be
/// used to safely eliminate the boilerplate that is typically incurred when working with multiple
/// mutable fields on state.
///
/// > Note: It is not necessary to annotate _every_ field with `@BindingState`, and in fact it is
/// > not recommended. Marking a field with the property wrapper makes it instantly mutable from the
/// > outside, which may hurt the encapsulation of your feature. It is best to limit the usage of
/// > the property wrapper to only those fields that need to have bindings derived for handing to
/// > SwiftUI components.
///
/// Read <doc:Bindings> for more information.
@available(iOS, deprecated: 9999, message: "Deriving bindings directly from stores using '@ObservableState'. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#BindingState")
@available(macOS, deprecated: 9999, message: "Deriving bindings directly from stores using '@ObservableState'. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#BindingState")
@available(tvOS, deprecated: 9999, message: "Deriving bindings directly from stores using '@ObservableState'. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#BindingState")
@available(watchOS, deprecated: 9999, message: "Deriving bindings directly from stores using '@ObservableState'. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#BindingState")
@propertyWrapper public struct BindingState<Value> {

    /// The underlying value wrapped by the binding state.
    public var wrappedValue: Value

    /// Creates bindable state from the value of another bindable state.
    public init(wrappedValue: Value, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)

    /// A projection that can be used to derive bindings from a view store.
    ///
    /// Use the projected value to derive bindings from a view store with properties annotated with
    /// `@BindingState`. To get the `projectedValue`, prefix the property with `$`:
    ///
    /// ```swift
    /// TextField("Display name", text: viewStore.$displayName)
    /// ```
    ///
    /// See ``BindingState`` for more details.
    public var projectedValue: ComposableArchitecture.BindingState<Value>
}

extension BindingState : Equatable where Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.BindingState<Value>, rhs: ComposableArchitecture.BindingState<Value>) -> Bool
}

extension BindingState : Hashable where Value : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension BindingState : Decodable where Value : Decodable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

extension BindingState : Encodable where Value : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

extension BindingState : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension BindingState : CustomDump.CustomDumpRepresentable {

    /// The custom dump value for this instance.
    public var customDumpValue: Any { get }
}

extension BindingState : CustomDebugStringConvertible where Value : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension BindingState : Sendable where Value : Sendable {
}

/// A property wrapper type that can designate properties of view state that can be directly
/// bindable in SwiftUI views.
///
/// Read <doc:Bindings> for more information.
@dynamicMemberLookup @propertyWrapper public struct BindingViewState<Value> {

    public var wrappedValue: Value

    public var projectedValue: Binding<Value> { get }

    public subscript<Subject>(dynamicMember keyPath: WritableKeyPath<Value, Subject>) -> ComposableArchitecture.BindingViewState<Subject> { get }
}

extension BindingViewState : Equatable where Value : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.BindingViewState<Value>, rhs: ComposableArchitecture.BindingViewState<Value>) -> Bool
}

extension BindingViewState : Hashable where Value : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension BindingViewState : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

extension BindingViewState : CustomDump.CustomDumpRepresentable {

    /// The custom dump value for this instance.
    public var customDumpValue: Any { get }
}

extension BindingViewState : CustomDebugStringConvertible where Value : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

/// A property wrapper type that can derive ``BindingViewState`` values for a ``ViewStore``.
///
/// Read <doc:Bindings> for more information.
@MainActor @dynamicMemberLookup @propertyWrapper @preconcurrency public struct BindingViewStore<State> {

    @MainActor public init(projectedValue: ComposableArchitecture.BindingViewStore<State>)

    @MainActor public var wrappedValue: State { get }

    @MainActor public var projectedValue: ComposableArchitecture.BindingViewStore<State>

    @MainActor public subscript<Value>(dynamicMember keyPath: KeyPath<State, Value>) -> Value { get }

    @MainActor public subscript<Value>(dynamicMember keyPath: WritableKeyPath<State, ComposableArchitecture.BindingState<Value>>) -> ComposableArchitecture.BindingViewState<Value> where Value : Equatable, Value : Sendable { get }
}

public class CancellablesCollection {

    public var count: Int { get }

    public func removeAll()
}

/// A view that handles a specific case of enum state in a ``SwitchStore``.
@available(iOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@available(macOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@available(tvOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@available(watchOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@MainActor public struct CaseLet<EnumState, EnumAction, CaseState, CaseAction, Content> : View where Content : View {

    @MainActor public let toCaseState: (EnumState) -> CaseState?

    @MainActor public let fromCaseAction: (CaseAction) -> EnumAction

    @MainActor public let content: (ComposableArchitecture.Store<CaseState, CaseAction>) -> Content

    /// Initializes a ``CaseLet`` view that computes content depending on if a store of enum state
    /// matches a particular case.
    ///
    /// - Parameters:
    ///   - toCaseState: A function that can extract a case of switch store state, which can be
    ///     specified using case path literal syntax, _e.g._ `/State.case`.
    ///   - fromCaseAction: A function that can embed a case action in a switch store action.
    ///   - content: A function that is given a store of the given case's state and returns a view
    ///     that is visible only when the switch store's state matches.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public init(_ toCaseState: @escaping (EnumState) -> CaseState?, action fromCaseAction: @escaping (CaseAction) -> EnumAction, @ViewBuilder then content: @escaping (_ store: ComposableArchitecture.Store<CaseState, CaseAction>) -> Content, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

extension CaseLet where EnumAction == CaseAction {

    /// Initializes a ``CaseLet`` view that computes content depending on if a store of enum state
    /// matches a particular case.
    ///
    /// - Parameters:
    ///   - toCaseState: A function that can extract a case of switch store state, which can be
    ///     specified using case path literal syntax, _e.g._ `/State.case`.
    ///   - content: A function that is given a store of the given case's state and returns a view
    ///     that is visible only when the switch store's state matches.
    @MainActor public init(state toCaseState: @escaping (EnumState) -> CaseState?, @ViewBuilder then content: @escaping (_ store: ComposableArchitecture.Store<CaseState, CaseAction>) -> Content)
}

/// A reducer represented by multiple enum cases.
///
/// You should not conform to this protocol directly. Instead, the ``Reducer()`` macro will add a
/// conformance to enums.
public protocol CaseReducer<State, Action> : ComposableArchitecture.Reducer where Self.Action == Self.Body.Action, Self.Body : ComposableArchitecture.Reducer, Self.State : ComposableArchitecture.CaseReducerState, Self.State == Self.Body.State {

    /// A type that holds the current state of the reducer.
    associatedtype State = Self.State

    /// A type that holds all possible actions that cause the ``State`` of the reducer to change
    /// and/or kick off a side ``Effect`` that can communicate with the outside world.
    associatedtype Action = Self.Action

    /// A type representing the body of this reducer.
    ///
    /// When you create a custom reducer by implementing the ``body-swift.property``, Swift infers
    /// this type from the value returned.
    ///
    /// If you create a custom reducer by implementing the ``reduce(into:action:)-1t2ri``, Swift
    /// infers this type to be `Never`.
    associatedtype Body = Self.Body

    associatedtype CaseScope

    @ComposableArchitecture.ReducerBuilder<Self.State, Self.Action> static var body: Self.Body { get }

    @MainActor @preconcurrency static func scope(_ store: ComposableArchitecture.Store<Self.State, Self.Action>) -> Self.CaseScope
}

extension CaseReducer {

    /// The content and behavior of a reducer that is composed from other reducers.
    ///
    /// In the body of a reducer one can compose many reducers together, which will be run in order,
    /// from top to bottom, and usually involves some reducer operations for integrating, such as
    /// `ifLet`, `forEach`, `_printChanges`, etc.:
    ///
    /// ```swift
    /// var body: some ReducerOf<Self> {
    ///   Reduce { state, action in
    ///     â€¦
    ///   }
    ///   .ifLet(\.child, action: \.child) {
    ///     ChildFeature()
    ///   }
    ///   ._printChanges()
    ///
    ///   Analytics()
    /// }
    /// ```
    ///
    /// Do not invoke this property directly.
    ///
    /// > Important: if your reducer implements the ``reduce(into:action:)-1t2ri`` method, it will
    /// > take precedence over this property, and only ``reduce(into:action:)-1t2ri`` will be called
    /// > by the ``Store``. If your reducer assembles a body from other reducers and has additional
    /// > business logic it needs to layer into the system, introduce this logic into the body
    /// > instead, either with ``Reduce``, or with a separate, dedicated conformance.
    public var body: Self.Body { get }
}

/// A state type that is associated with a ``CaseReducer``.
public protocol CaseReducerState {

    associatedtype StateReducer : ComposableArchitecture.CaseReducer where Self == Self.StateReducer.State
}

/// Combines multiple reducers into a single reducer.
///
/// `CombineReducers` takes a block that can combine a number of reducers using a
/// ``ReducerBuilder``.
///
/// Useful for grouping reducers together and applying reducer modifiers to the result.
///
/// ```swift
/// var body: some Reducer<State, Action> {
///   CombineReducers {
///     ReducerA()
///     ReducerB()
///     ReducerC()
///   }
///   ._printChanges()
/// }
/// ```
public struct CombineReducers<State, Action, Reducers> : ComposableArchitecture.Reducer where State == Reducers.State, Action == Reducers.Action, Reducers : ComposableArchitecture.Reducer {

    /// Initializes a reducer that combines all of the reducers in the given build block.
    ///
    /// - Parameter build: A reducer builder.
    @inlinable public init(@ComposableArchitecture.ReducerBuilder<State, Action> _ build: () -> Reducers)

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout Reducers.State, action: Reducers.Action) -> ComposableArchitecture.Effect<Reducers.Action>
}

@MainActor @preconcurrency public struct DestinationContent<State, Action> {

    @MainActor public func callAsFunction<Content>(@ViewBuilder _ body: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Content) -> some View where Content : View

}

/// An effect that dismisses the current presentation.
///
/// Execute this in the effect returned from a reducer in order to dismiss the feature:
///
/// ```swift
/// @Reducer
/// struct ChildFeature {
///   struct State { /* ... */ }
///   enum Action {
///     case exitButtonTapped
///     // ...
///   }
///   @Dependency(\.dismiss) var dismiss
///   var body: some Reducer<State, Action> {
///     Reduce { state, action in
///       switch action {
///       case .exitButtonTapped:
///         return .run { _ in await self.dismiss() }
///       // ...
///       }
///     }
///   }
/// }
/// ```
///
/// This operation works by finding the nearest parent feature that was presented using either the
/// ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` or the
/// ``Reducer/forEach(_:action:destination:fileID:filePath:line:column:)-9svqb`` operator, and then dismisses _that_
/// feature. It performs the dismissal by either sending the ``PresentationAction/dismiss`` in the
/// case of `ifLet` or sending ``StackAction/popFrom(id:)`` in the case of `forEach`.
///
/// It is also possible to dismiss the feature using an animation by providing an argument to the
/// `dismiss` function:
///
/// ```swift
/// case .exitButtonTapped:
///   return .run { _ in await self.dismiss(animation: .default) }
/// ```
///
/// This will cause the `dismiss` or `popFrom(id:)` action to be sent with the particular animation.
///
/// > Warning: The `@Dependency(\.dismiss)` tool only works for features that are presented using
/// > the `ifLet` operator for tree-based navigation (see <doc:TreeBasedNavigation> for more info)
/// > or `forEach` operator for stack-based navigation (see <doc:StackBasedNavigation>). If no
/// > parent feature is found that was presented with `ifLet` or `forEach`, then a runtime warning
/// > is emitted in Xcode letting you know that it is not possible to dismiss. Further, the runtime
/// > warning becomes a test failure when run in tests.
/// >
/// > If you are testing a child feature in isolation that makes use of `@Dependency(\.dismiss)`
/// > then you will need to override the dependency to get a passing test. You can even mutate
/// > some shared mutable state inside the `dismiss` closure to confirm that it is indeed invoked:
/// >
/// > ```swift
/// > let isDismissInvoked: LockIsolated<[Bool]> = .init([])
/// > let store = TestStore(initialState: Child.State()) {
/// >   Child()
/// > } withDependencies: {
/// >   $0.dismiss = DismissEffect { isDismissInvoked.withValue { $0.append(true) } }
/// > }
/// >
/// > await store.send(.exitButtonTapped) {
/// >   // ...
/// > }
/// > XCTAssertEqual(isDismissInvoked.value, [true])
/// > ```
public struct DismissEffect : Sendable {

    @MainActor public func callAsFunction(fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    @MainActor public func callAsFunction(animation: Animation?, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    @MainActor public func callAsFunction(transaction: Transaction, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async
}

extension DismissEffect {

    public init(_ dismiss: @escaping @MainActor @Sendable () -> Void)
}

public struct Effect<Action> : Sendable {
}

extension Effect {

    /// An effect that does nothing and completes immediately. Useful for situations where you must
    /// return an effect, but you don't need to do anything.
    @inlinable public static var none: ComposableArchitecture.Effect<Action> { get }

    /// Wraps an asynchronous unit of work that can emit actions any number of times in an effect.
    ///
    /// For example, if you had an async sequence in a dependency client:
    ///
    /// ```swift
    /// struct EventsClient {
    ///   var events: () -> any AsyncSequence<Event, Never>
    /// }
    /// ```
    ///
    /// Then you could attach to it in a `run` effect by using `for await` and sending each action of
    /// the stream back into the system:
    ///
    /// ```swift
    /// case .startButtonTapped:
    ///   return .run { send in
    ///     for await event in self.events() {
    ///       send(.event(event))
    ///     }
    ///   }
    /// ```
    ///
    /// See ``Send`` for more information on how to use the `send` argument passed to `run`'s closure.
    ///
    /// The closure provided to ``run(priority:operation:catch:fileID:filePath:line:column:)`` is
    /// allowed to throw, but any non-cancellation errors thrown will cause a runtime warning when run
    /// in the simulator or on a device, and will cause a test failure in tests. To catch
    /// non-cancellation errors use the `catch` trailing closure.
    ///
    /// - Parameters:
    ///   - priority: Priority of the underlying task. If `nil`, the priority will come from
    ///     `Task.currentPriority`.
    ///   - name: An optional name to associate with the task that runs this effect.
    ///   - operation: The operation to execute.
    ///   - handler: An error handler, invoked if the operation throws an error other than
    ///     `CancellationError`.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: An effect wrapping the given asynchronous work.
    public static func run(priority: TaskPriority? = nil, name: String? = nil, operation: @escaping @Sendable (_ send: ComposableArchitecture.Send<Action>) async throws -> Void, catch handler: (@Sendable (_ error: any Error, _ send: ComposableArchitecture.Send<Action>) async -> Void)? = nil, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> ComposableArchitecture.Effect<Action>

    /// Initializes an effect that immediately emits the action passed in.
    ///
    /// > Note: We do not recommend using `Effect.send` to share logic. Instead, limit usage to
    /// > child-parent communication, where a child may want to emit a "delegate" action for a parent
    /// > to listen to.
    /// >
    /// > For more information, see <doc:Performance#Sharing-logic-with-actions>.
    ///
    /// - Parameter action: The action that is immediately emitted by the effect.
    public static func send(_ action: Action) -> ComposableArchitecture.Effect<Action>

    /// Initializes an effect that immediately emits the action passed in.
    ///
    /// > Note: We do not recommend using `Effect.send` to share logic. Instead, limit usage to
    /// > child-parent communication, where a child may want to emit a "delegate" action for a parent
    /// > to listen to.
    /// >
    /// > For more information, see <doc:Performance#Sharing-logic-with-actions>.
    ///
    /// - Parameters:
    ///   - action: The action that is immediately emitted by the effect.
    ///   - animation: An animation.
    public static func send(_ action: Action, animation: Animation? = nil) -> ComposableArchitecture.Effect<Action>
}

extension Effect {

    /// Merges a variadic list of effects together into a single effect, which runs the effects at the
    /// same time.
    ///
    /// - Parameter effects: A variadic list of effects.
    /// - Returns: A new effect
    @inlinable public static func merge(_ effects: ComposableArchitecture.Effect<Action>...) -> ComposableArchitecture.Effect<Action>

    /// Merges a sequence of effects together into a single effect, which runs the effects at the same
    /// time.
    ///
    /// - Parameter effects: A sequence of effects.
    /// - Returns: A new effect
    @inlinable public static func merge(_ effects: some Sequence<ComposableArchitecture.Effect<Action>>) -> ComposableArchitecture.Effect<Action>

    /// Merges this effect and another into a single effect that runs both at the same time.
    ///
    /// - Parameter other: Another effect.
    /// - Returns: An effect that runs this effect and the other at the same time.
    @inlinable public func merge(with other: ComposableArchitecture.Effect<Action>) -> ComposableArchitecture.Effect<Action>

    /// Concatenates a variadic list of effects together into a single effect, which runs the effects
    /// one after the other.
    ///
    /// - Parameter effects: A variadic list of effects.
    /// - Returns: A new effect
    @inlinable public static func concatenate(_ effects: ComposableArchitecture.Effect<Action>...) -> ComposableArchitecture.Effect<Action>

    /// Concatenates a collection of effects together into a single effect, which runs the effects one
    /// after the other.
    ///
    /// - Parameter effects: A collection of effects.
    /// - Returns: A new effect
    @inlinable public static func concatenate(_ effects: some Collection<ComposableArchitecture.Effect<Action>>) -> ComposableArchitecture.Effect<Action>

    /// Concatenates this effect and another into a single effect that first runs this effect, and
    /// after it completes or is cancelled, runs the other.
    ///
    /// - Parameter other: Another effect.
    /// - Returns: An effect that runs this effect, and after it completes or is cancelled, runs the
    ///   other.
    @inlinable public func concatenate(with other: ComposableArchitecture.Effect<Action>) -> ComposableArchitecture.Effect<Action>

    /// Transforms all elements from the upstream effect with a provided closure.
    ///
    /// - Parameter transform: A closure that transforms the upstream effect's action to a new action.
    /// - Returns: A publisher that uses the provided closure to map elements from the upstream effect
    ///   to new elements that it then publishes.
    @inlinable public func map<T>(_ transform: @escaping @Sendable (Action) -> T) -> ComposableArchitecture.Effect<T>
}

extension Effect {

    /// Wraps the emission of each element with SwiftUI's `withAnimation`.
    ///
    /// ```swift
    /// case .buttonTapped:
    ///   return .run { send in
    ///     await send(.activityResponse(self.apiClient.fetchActivity()))
    ///   }
    ///   .animation()
    /// ```
    ///
    /// - Parameter animation: An animation.
    /// - Returns: A publisher.
    public func animation(_ animation: Animation? = .default) -> ComposableArchitecture.Effect<Action>

    /// Wraps the emission of each element with SwiftUI's `withTransaction`.
    ///
    /// ```swift
    /// case .buttonTapped:
    ///   var transaction = Transaction(animation: .default)
    ///   transaction.disablesAnimations = true
    ///   return .run { send in
    ///     await send(.activityResponse(self.apiClient.fetchActivity()))
    ///   }
    ///   .transaction(transaction)
    /// ```
    ///
    /// - Parameter transaction: A transaction.
    /// - Returns: A publisher.
    public func transaction(_ transaction: Transaction) -> ComposableArchitecture.Effect<Action>
}

extension Effect {

    /// Turns an effect into one that is capable of being canceled.
    ///
    /// To turn an effect into a cancellable one you must provide an identifier, which is used in
    /// ``Effect/cancel(id:)`` to identify which in-flight effect should be canceled.
    /// Any hashable value can be used for the identifier, such as a string, but you can add a bit of
    /// protection against typos by defining a new type for the identifier:
    ///
    /// ```swift
    /// enum CancelID { case loadUser }
    ///
    /// case .reloadButtonTapped:
    ///   // Start a new effect to load the user
    ///   return .run { send in
    ///     await send(
    ///       .userResponse(
    ///         await Result { try await self.apiClient.loadUser() }
    ///       )
    ///     )
    ///   }
    ///   .cancellable(id: CancelID.loadUser, cancelInFlight: true)
    ///
    /// case .cancelButtonTapped:
    ///   // Cancel any in-flight requests to load the user
    ///   return .cancel(id: CancelID.loadUser)
    /// ```
    ///
    /// - Parameters:
    ///   - id: The effect's identifier.
    ///   - cancelInFlight: Determines if any in-flight effect with the same identifier should be
    ///     canceled before starting this new one.
    /// - Returns: A new effect that is capable of being canceled by an identifier.
    public func cancellable(id: some Hashable & Sendable, cancelInFlight: Bool = false) -> ComposableArchitecture.Effect<Action>

    /// An effect that will cancel any currently in-flight effect with the given identifier.
    ///
    /// - Parameter id: An effect identifier.
    /// - Returns: A new effect that will cancel any currently in-flight effect with the given
    ///   identifier.
    public static func cancel(id: some Hashable & Sendable) -> ComposableArchitecture.Effect<Action>
}

extension Effect {

    /// Turns an effect into one that can be debounced.
    ///
    /// To turn an effect into a debounce-able one you must provide an identifier, which is used to
    /// determine which in-flight effect should be canceled in order to start a new effect. Any
    /// hashable value can be used for the identifier, such as a string, but you can add a bit of
    /// protection against typos by defining a new type that conforms to `Hashable`, such as an enum:
    ///
    /// ```swift
    /// case let .textChanged(text):
    ///   enum CancelID { case search }
    ///
    ///   return .run { send in
    ///     await send(
    ///       .searchResponse(
    ///         await Result { await self.apiClient.search(text) }
    ///       )
    ///     )
    ///   }
    ///   .debounce(id: CancelID.search, for: 0.5, scheduler: self.mainQueue)
    /// ```
    ///
    /// - Parameters:
    ///   - id: The effect's identifier.
    ///   - dueTime: The duration you want to debounce for.
    ///   - scheduler: The scheduler you want to deliver the debounced output to.
    ///   - options: Scheduler options that customize the effect's delivery of elements.
    /// - Returns: An effect that publishes events only after a specified time elapses.
    public func debounce<S>(id: some Hashable & Sendable, for dueTime: S.SchedulerTimeType.Stride, scheduler: S, options: S.SchedulerOptions? = nil) -> ComposableArchitecture.Effect<Action> where S : Scheduler
}

extension Effect {

    /// Creates an effect from a Combine publisher.
    ///
    /// - Parameter createPublisher: The closure to execute when the effect is performed.
    /// - Returns: An effect wrapping a Combine publisher.
    public static func publisher(_ createPublisher: () -> some Publisher<Action, Never>) -> ComposableArchitecture.Effect<Action>
}

extension Effect where Action : Sendable {

    /// Throttles an effect so that it only publishes one output per given interval.
    ///
    /// The throttling of an effect is with respect to actions being sent into the store. So, if
    /// you return a throttled effect from an action that is sent with high frequency, the effect
    /// will be executed at most once per interval specified.
    ///
    /// > Note: It is usually better to perform throttling logic in the _view_ in order to limit
    /// the number of actions sent into the system. Only use this operator if your reducer needs to
    /// layer on specialized logic for throttling. See <doc:Performance> for more information of why
    /// sending high-frequency actions into a store is typically not what you want to do.
    ///
    /// - Parameters:
    ///   - id: The effect's identifier.
    ///   - interval: The interval at which to find and emit the most recent element, expressed in
    ///     the time system of the scheduler.
    ///   - scheduler: The scheduler you want to deliver the throttled output to.
    ///   - latest: A boolean value that indicates whether to publish the most recent element. If
    ///     `false`, the publisher emits the first element received during the interval.
    /// - Returns: An effect that emits either the most-recent or first element received during the
    ///   specified interval.
    public func throttle<S>(id: some Hashable & Sendable, for interval: S.SchedulerTimeType.Stride, scheduler: S, latest: Bool) -> ComposableArchitecture.Effect<Action> where S : Scheduler, S : Sendable, S.SchedulerTimeType.Stride : Sendable
}

extension Effect where Action : Sendable {

    public var actions: AsyncStream<Action> { get }
}

/// A convenience type alias for referring to an effect of a given reducer's domain.
///
/// Instead of specifying the action:
///
/// ```swift
/// let effect: Effect<Feature.Action>
/// ```
///
/// You can specify the reducer:
///
/// ```swift
/// let effect: EffectOf<Feature>
/// ```
public typealias EffectOf<R> = ComposableArchitecture.Effect<R.Action> where R : ComposableArchitecture.Reducer

/// A reducer that does nothing.
///
/// While not very useful on its own, `EmptyReducer` can be used as a placeholder in APIs that hold
/// reducers.
public struct EmptyReducer<State, Action> : ComposableArchitecture.Reducer {

    /// Initializes a reducer that does nothing.
    @inlinable public init()

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into _: inout State, action _: Action) -> ComposableArchitecture.Effect<Action>
}

/// The exhaustivity of assertions made by the test store.
public enum Exhaustivity : Equatable, Sendable {

    /// Exhaustive assertions.
    ///
    /// This setting requires you to exhaustively assert on all state changes and all actions received
    /// from effects. Additionally, all in-flight effects _must_ be received before the test store is
    /// deallocated.
    ///
    /// To manually skip actions or effects, use
    /// ``TestStore/skipReceivedActions(strict:fileID:file:line:column:)`` or
    /// ``TestStore/skipInFlightEffects(strict:fileID:file:line:column:)``.
    ///
    /// To partially match an action received from an effect, use
    /// ``TestStore/receive(_:timeout:assert:fileID:file:line:column:)-53wic`` or
    /// ``TestStore/receive(_:timeout:assert:fileID:file:line:column:)-35638``.
    case on

    /// Non-exhaustive assertions.
    ///
    /// This settings allows you to assert on any subset of state changes and actions received from
    /// effects.
    ///
    /// When configured to `showSkippedAssertions`, any state not asserted on or received actions
    /// skipped will be reported in a grey informational box next to the assertion. This is handy for
    /// when you want non-exhaustivity but you still want to know what all you are missing from your
    /// assertions.
    ///
    /// - Parameter showSkippedAssertions: When `true`, skipped assertions will be reported as
    ///   expected failures.
    case off(showSkippedAssertions: Bool)

    /// Non-exhaustive assertions.
    public static let off: ComposableArchitecture.Exhaustivity
}

/// A Composable Architecture-friendly wrapper around `ForEach` that simplifies working with
/// collections of state.
///
/// ``ForEachStore`` loops over a store's collection with a store scoped to the domain of each
/// element. This allows you to extract and modularize an element's view and avoid concerns around
/// collection index math and parent-child store communication.
///
/// For example, a todos app may define the domain and logic associated with an individual todo:
///
/// ```swift
/// @Reducer
/// struct Todo {
///   struct State: Equatable, Identifiable {
///     let id: UUID
///     var description = ""
///     var isComplete = false
///   }
///
///   enum Action {
///     case isCompleteToggled(Bool)
///     case descriptionChanged(String)
///   }
///
///   var body: some Reducer<State, Action> {
///     // ...
///   }
/// }
/// ```
///
/// As well as a view with a domain-specific store:
///
/// ```swift
/// struct TodoView: View {
///   let store: StoreOf<Todo>
///   var body: some View { /* ... */ }
/// }
/// ```
///
/// For a parent domain to work with a collection of todos, it can hold onto this collection in
/// state:
///
/// ```swift
/// @Reducer
/// struct Todos {
///   struct State: Equatable {
///     var todos: IdentifiedArrayOf<Todo.State> = []
///   }
///   // ...
/// }
/// ```
///
/// Define a case to handle actions sent to the child domain:
///
/// ```swift
/// enum Action {
///   case todos(IdentifiedActionOf<Todo>)
/// }
/// ```
///
/// Enhance its core reducer using
/// ``Reducer/forEach(_:action:element:fileID:filePath:line:column:)-6zye8``:
///
/// ```swift
/// var body: some Reducer<State, Action> {
///   Reduce { state, action in
///     // ...
///   }
///   .forEach(\.todos, action: \.todos) {
///     Todo()
///   }
/// }
/// ```
///
/// And finally render a list of `TodoView`s using ``ForEachStore``:
///
/// ```swift
/// ForEachStore(
///   self.store.scope(state: \.todos, action: \.todos)
/// ) { todoStore in
///   TodoView(store: todoStore)
/// }
/// ```
///
@available(iOS, deprecated: 9999, message: "Pass 'ForEach' a store scoped to an identified array and identified action, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-ForEachStore-with-ForEach]")
@available(macOS, deprecated: 9999, message: "Pass 'ForEach' a store scoped to an identified array and identified action, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-ForEachStore-with-ForEach]")
@available(tvOS, deprecated: 9999, message: "Pass 'ForEach' a store scoped to an identified array and identified action, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-ForEachStore-with-ForEach]")
@available(watchOS, deprecated: 9999, message: "Pass 'ForEach' a store scoped to an identified array and identified action, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-ForEachStore-with-ForEach]")
@MainActor public struct ForEachStore<EachState, EachAction, Data, ID, Content> : View where Data : Collection, ID : Hashable, ID : Sendable, Content : View {

    /// The collection of underlying data.
    @MainActor public let data: Data

    /// Initializes a structure that computes views on demand from a store on a collection of data and
    /// an identified action.
    ///
    /// - Parameters:
    ///   - store: A store on an identified array of data and an identified action.
    ///   - content: A function that can generate content given a store of an element.
    @MainActor @preconcurrency public init<EachContent>(_ store: ComposableArchitecture.Store<IdentifiedCollections.IdentifiedArray<ID, EachState>, ComposableArchitecture.IdentifiedAction<ID, EachAction>>, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<EachState, EachAction>) -> EachContent) where Data == IdentifiedCollections.IdentifiedArray<ID, EachState>, Content == ComposableArchitecture.WithViewStore<IdentifiedCollections.IdentifiedArray<ID, EachState>, ComposableArchitecture.IdentifiedAction<ID, EachAction>, ForEach<IdentifiedCollections.IdentifiedArray<ID, EachState>, ID, EachContent>>, EachContent : View

    @available(iOS, deprecated: 9999, message: "Use an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Identified-actions")
    @available(macOS, deprecated: 9999, message: "Use an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Identified-actions")
    @available(tvOS, deprecated: 9999, message: "Use an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Identified-actions")
    @available(watchOS, deprecated: 9999, message: "Use an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Identified-actions")
    @MainActor @preconcurrency public init<EachContent>(_ store: ComposableArchitecture.Store<IdentifiedCollections.IdentifiedArray<ID, EachState>, (id: ID, action: EachAction)>, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<EachState, EachAction>) -> EachContent) where Data == IdentifiedCollections.IdentifiedArray<ID, EachState>, Content == ComposableArchitecture.WithViewStore<IdentifiedCollections.IdentifiedArray<ID, EachState>, (id: ID, action: EachAction), ForEach<IdentifiedCollections.IdentifiedArray<ID, EachState>, ID, EachContent>>, EachContent : View

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

extension ForEachStore : @preconcurrency DynamicViewContent {
}

/// A wrapper type for actions that can be presented in a list.
///
/// Use this type for modeling a feature's domain that needs to present child features using
/// ``Reducer/forEach(_:action:element:fileID:filePath:line:column:)-6zye8``.
public enum IdentifiedAction<ID, Action> : CasePathsCore.CasePathable where ID : Hashable, ID : Sendable {

    /// An action sent to the element at a given identifier.
    case element(id: ID, action: Action)

    /// A collection of all case paths of this type.
    public static var allCasePaths: ComposableArchitecture.IdentifiedAction<ID, Action>.AllCasePaths { get }

    /// A type that can represent a collection of all case paths of this type.
    public struct AllCasePaths {

        public var element: CasePathsCore.AnyCasePath<ComposableArchitecture.IdentifiedAction<ID, Action>, (id: ID, action: Action)> { get }

        public subscript(id id: ID) -> CasePathsCore.AnyCasePath<ComposableArchitecture.IdentifiedAction<ID, Action>, Action> { get }
    }
}

extension IdentifiedAction : Equatable where Action : Equatable {
}

extension IdentifiedAction : Hashable where Action : Hashable {
}

extension IdentifiedAction : Sendable where Action : Sendable {
}

extension IdentifiedAction : Decodable where ID : Decodable, Action : Decodable {
}

extension IdentifiedAction : Encodable where ID : Encodable, Action : Encodable {
}

/// A convenience type alias for referring to an identified action of a given reducer's domain.
///
/// Instead of specifying the action like this:
///
/// ```swift
/// case rows(IdentifiedAction<ChildFeature.State.ID, ChildFeature.Action>)
/// ```
///
/// You can specify the reducer:
///
/// ```swift
/// case rows(IdentifiedActionOf<ChildFeature>)
/// ```
public typealias IdentifiedActionOf<R> = ComposableArchitecture.IdentifiedAction<R.State.ID, R.Action> where R : ComposableArchitecture.Reducer, R.State : Identifiable

/// A view that safely unwraps a store of optional state in order to show one of two views.
///
/// When the underlying state is non-`nil`, the `then` closure will be performed with a ``Store``
/// that holds onto non-optional state, and otherwise the `else` closure will be performed.
///
/// This is useful for deciding between two views to show depending on an optional piece of state:
///
/// ```swift
/// IfLetStore(
///   store.scope(state: \.results, action: { .results($0) })
/// ) {
///   SearchResultsView(store: $0)
/// } else: {
///   Text("Loading search results...")
/// }
/// ```
///
@available(iOS, deprecated: 9999, message: "Use 'if let' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-IfLetStore-with-if-let]")
@available(macOS, deprecated: 9999, message: "Use 'if let' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-IfLetStore-with-if-let]")
@available(tvOS, deprecated: 9999, message: "Use 'if let' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-IfLetStore-with-if-let]")
@available(watchOS, deprecated: 9999, message: "Use 'if let' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-IfLetStore-with-if-let]")
@MainActor public struct IfLetStore<State, Action, Content> : View where Content : View {

    /// Initializes an ``IfLetStore`` view that computes content depending on if a store of optional
    /// state is `nil` or non-`nil`.
    ///
    /// - Parameters:
    ///   - store: A store of optional state.
    ///   - ifContent: A function that is given a store of non-optional state and returns a view that
    ///     is visible only when the optional state is non-`nil`.
    ///   - elseContent: A view that is only visible when the optional state is `nil`.
    @MainActor @preconcurrency public init<IfContent, ElseContent>(_ store: ComposableArchitecture.Store<State?, Action>, @ViewBuilder then ifContent: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> IfContent, @ViewBuilder else elseContent: () -> ElseContent) where Content == _ConditionalContent<IfContent, ElseContent>, IfContent : View, ElseContent : View

    /// Initializes an ``IfLetStore`` view that computes content depending on if a store of optional
    /// state is `nil` or non-`nil`.
    ///
    /// - Parameters:
    ///   - store: A store of optional state.
    ///   - ifContent: A function that is given a store of non-optional state and returns a view that
    ///     is visible only when the optional state is non-`nil`.
    @MainActor @preconcurrency public init<IfContent>(_ store: ComposableArchitecture.Store<State?, Action>, @ViewBuilder then ifContent: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> IfContent) where Content == IfContent?, IfContent : View

    /// Initializes an ``IfLetStore`` view that computes content depending on if a store of
    /// ``PresentationState`` and ``PresentationAction`` is `nil` or non-`nil`.
    ///
    /// - Parameters:
    ///   - store: A store of optional state.
    ///   - ifContent: A function that is given a store of non-optional state and returns a view that
    ///     is visible only when the optional state is non-`nil`.
    ///   - elseContent: A view that is only visible when the optional state is `nil`.
    @available(iOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public init<IfContent, ElseContent>(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder then ifContent: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> IfContent, @ViewBuilder else elseContent: @escaping () -> ElseContent) where Content == _ConditionalContent<IfContent, ElseContent>, IfContent : View, ElseContent : View

    /// Initializes an ``IfLetStore`` view that computes content depending on if a store of
    /// ``PresentationState`` and ``PresentationAction`` is `nil` or non-`nil`.
    ///
    /// - Parameters:
    ///   - store: A store of optional state.
    ///   - ifContent: A function that is given a store of non-optional state and returns a view that
    ///     is visible only when the optional state is non-`nil`.
    @available(iOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Scope the store into the destination's wrapped 'state' and presented 'action', instead: 'store.scope(state: \\.destination, action: \\.destination.presented)'. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public init<IfContent>(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder then ifContent: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> IfContent) where Content == IfContent?, IfContent : View

    /// Initializes an ``IfLetStore`` view that computes content depending on if a store of
    /// ``PresentationState`` and ``PresentationAction`` is `nil` or non-`nil` and state can further
    /// be extracted from the destination state, _e.g._ it matches a particular case of an enum.
    ///
    /// - Parameters:
    ///   - store: A store of optional state.
    ///   - toState: A closure that attempts to extract state for the "if" branch from the destination
    ///     state.
    ///   - fromAction: A closure that embeds actions for the "if" branch in destination actions.
    ///   - ifContent: A function that is given a store of non-optional state and returns a view that
    ///     is visible only when the optional state is non-`nil` and state can be extracted from the
    ///     destination state.
    ///   - elseContent: A view that is only visible when state cannot be extracted from the
    ///     destination.
    @available(*, deprecated, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public init<DestinationState, DestinationAction, IfContent, ElseContent>(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<DestinationState>, ComposableArchitecture.PresentationAction<DestinationAction>>, state toState: @escaping (_ destinationState: DestinationState) -> State?, action fromAction: @escaping (_ action: Action) -> DestinationAction, @ViewBuilder then ifContent: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> IfContent, @ViewBuilder else elseContent: @escaping () -> ElseContent) where Content == _ConditionalContent<IfContent, ElseContent>, IfContent : View, ElseContent : View

    /// Initializes an ``IfLetStore`` view that computes content depending on if a store of
    /// ``PresentationState`` and ``PresentationAction`` is `nil` or non-`nil` and state can further
    /// be extracted from the destination state, _e.g._ it matches a particular case of an enum.
    ///
    /// - Parameters:
    ///   - store: A store of optional state.
    ///   - toState: A closure that attempts to extract state for the "if" branch from the destination
    ///     state.
    ///   - fromAction: A closure that embeds actions for the "if" branch in destination actions.
    ///   - ifContent: A function that is given a store of non-optional state and returns a view that
    ///     is visible only when the optional state is non-`nil` and state can be extracted from the
    ///     destination state.
    @available(*, deprecated, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public init<DestinationState, DestinationAction, IfContent>(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<DestinationState>, ComposableArchitecture.PresentationAction<DestinationAction>>, state toState: @escaping (_ destinationState: DestinationState) -> State?, action fromAction: @escaping (_ action: Action) -> DestinationAction, @ViewBuilder then ifContent: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> IfContent) where Content == IfContent?, IfContent : View

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

@available(*, deprecated, message: "Use '.inMemory' ('FileStorage.inMemory') instead")
public func InMemoryFileStorage() -> Sharing.FileStorage

@available(*, deprecated, message: "Use '.fileSystem' ('FileStorage.fileSystem') instead")
public func LiveFileStorage() -> Sharing.FileStorage

@MainActor @preconcurrency final public class Logger {

    @MainActor public static let shared: ComposableArchitecture.Logger

    @MainActor public var isEnabled: Bool

    @Published @MainActor public var logs: [String]

    @MainActor public func log(level: OSLogType = .default, _ string: @autoclosure () -> String)

    @MainActor public func clear()
}

/// A view that controls a navigation presentation.
///
/// This view is similar to SwiftUI's `NavigationLink`, but it allows driving navigation from an
/// optional or enum instead of just a boolean.
///
/// Typically you use this view by first modeling your features as having a parent feature that
/// holds onto an optional piece of child state using the ``PresentationState``,
/// ``PresentationAction`` and ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` tools (see
/// <doc:TreeBasedNavigation> for more information). Then in the view you can construct a
/// `NavigationLinkStore` by passing a ``Store`` that is focused on the presentation domain:
///
/// ```swift
/// NavigationLinkStore(
///   self.store.scope(state: \.$child, action: \.child)
/// ) {
///   viewStore.send(.linkTapped)
/// } destination: { store in
///   ChildView(store: store)
/// } label: {
///   Text("Go to child")
/// }
/// ```
///
/// Then when the `child` state flips from `nil` to non-`nil` a drill-down animation will occur to
/// the child domain.
@available(iOS, introduced: 13, deprecated: 16)
@available(macOS, introduced: 10.15, deprecated: 13)
@available(tvOS, introduced: 13, deprecated: 16)
@available(watchOS, introduced: 6, deprecated: 9)
@MainActor public struct NavigationLinkStore<State, Action, DestinationState, DestinationAction, Destination, Label> : View where Destination : View, Label : View {

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, onTap: @escaping () -> Void, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Destination, @ViewBuilder label: () -> Label) where State == DestinationState, Action == DestinationAction

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, onTap: @escaping () -> Void, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<DestinationState, DestinationAction>) -> Destination, @ViewBuilder label: () -> Label)

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, id: State.ID, onTap: @escaping () -> Void, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Destination, @ViewBuilder label: () -> Label) where State : Identifiable, State == DestinationState, Action == DestinationAction

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, id: DestinationState.ID, onTap: @escaping () -> Void, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<DestinationState, DestinationAction>) -> Destination, @ViewBuilder label: () -> Label) where DestinationState : Identifiable

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }

    @available(macOS, unavailable)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    @MainActor public func isDetailLink(_ isDetailLink: Bool) -> ComposableArchitecture.NavigationLinkStore<State, Action, DestinationState, DestinationAction, Destination, Label>
}

/// A navigation stack that is driven by a store.
///
/// This view can be used to drive stack-based navigation in the Composable Architecture when passed
/// a store that is focused on ``StackState`` and ``StackAction``.
///
/// See the dedicated article on <doc:Navigation> for more information on the library's navigation
/// tools, and in particular see <doc:StackBasedNavigation> for information on using this view.
@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
@available(iOS, deprecated: 9999, message: "Use 'NavigationStack.init(path:)' with a store scoped from observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-NavigationStackStore-with-NavigationStack]")
@available(macOS, deprecated: 9999, message: "Use 'NavigationStack.init(path:)' with a store scoped from observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-NavigationStackStore-with-NavigationStack]")
@available(tvOS, deprecated: 9999, message: "Use 'NavigationStack.init(path:)' with a store scoped from observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-NavigationStackStore-with-NavigationStack]")
@available(watchOS, deprecated: 9999, message: "Use 'NavigationStack.init(path:)' with a store scoped from observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-NavigationStackStore-with-NavigationStack]")
@MainActor public struct NavigationStackStore<State, Action, Root, Destination> : View where Root : View, Destination : View {

    /// Creates a navigation stack with a store of stack state and actions.
    ///
    /// - Parameters:
    ///   - store: A store of stack state and actions to power this stack.
    ///   - root: The view to display when the stack is empty.
    ///   - destination: A view builder that defines a view to display when an element is appended to
    ///     the stack's state. The closure takes one argument, which is a store of the value to
    ///     present.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.StackState<State>, ComposableArchitecture.StackAction<State, Action>>, @ViewBuilder root: () -> Root, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Destination, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)

    /// Creates a navigation stack with a store of stack state and actions.
    ///
    /// - Parameters:
    ///   - store: A store of stack state and actions to power this stack.
    ///   - root: The view to display when the stack is empty.
    ///   - destination: A view builder that defines a view to display when an element is appended to
    ///     the stack's state. The closure takes one argument, which is the initial enum state to
    ///     present. You can switch over this value and use ``CaseLet`` views to handle each case.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public init<D>(_ store: ComposableArchitecture.Store<ComposableArchitecture.StackState<State>, ComposableArchitecture.StackAction<State, Action>>, @ViewBuilder root: () -> Root, @ViewBuilder destination: @escaping (_ initialState: State) -> D, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) where Destination == ComposableArchitecture.SwitchStore<State, Action, D>, D : View

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

public protocol ObservableState : PerceptionCore.Perceptible {

    var _$id: ComposableArchitecture.ObservableStateID { get }

    mutating func _$willModify()
}

/// Defines and implements conformance of the Observable protocol.
@attached(extension, conformances: Observable, ComposableArchitecture.ObservableState) @attached(member, names: named(_$id), named(_$observationRegistrar), named(_$willModify), named(shouldNotifyObservers)) @attached(memberAttribute) public macro ObservableState() = #externalMacro(module: "ComposableArchitectureMacros", type: "ObservableStateMacro")

/// A unique identifier for a observed value.
public struct ObservableStateID : Equatable, Hashable, Sendable {

    public init()

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.ObservableStateID, rhs: ComposableArchitecture.ObservableStateID) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    @inlinable public static func _$id<T>(for value: T) -> ComposableArchitecture.ObservableStateID

    @inlinable public static func _$id(for value: some ComposableArchitecture.ObservableState) -> ComposableArchitecture.ObservableStateID

    public func _$tag(_ tag: Int) -> ComposableArchitecture.ObservableStateID

    @inlinable public mutating func _$willModify()
}

@attached(accessor, names: named(willSet)) public macro ObservationStateIgnored() = #externalMacro(module: "ComposableArchitectureMacros", type: "ObservationStateIgnoredMacro")

/// Provides storage for tracking and access to data changes.
public struct ObservationStateRegistrar : Sendable {

    public private(set) var id: ComposableArchitecture.ObservableStateID { get }

    public init()

    public mutating func _$willModify()
}

extension ObservationStateRegistrar : Equatable, Hashable, Codable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (_: ComposableArchitecture.ObservationStateRegistrar, _: ComposableArchitecture.ObservationStateRegistrar) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
extension ObservationStateRegistrar {

    /// Registers access to a specific property for observation.
    ///
    /// - Parameters:
    ///   - subject: An instance of an observable type.
    ///   - keyPath: The key path of an observed property.
    @inlinable public func access<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>) where Subject : Observable

    /// Mutates a value to a new value, and decided to notify observers based on the identity of
    /// the value.
    ///
    /// - Parameters:
    ///   - subject: An instance of an observable type.
    ///   - keyPath: The key path of an observed property.
    ///   - value: The value being mutated.
    ///   - newValue: The new value to mutate with.
    ///   - isIdentityEqual: A comparison function that determines whether two values have the
    ///     same identity or not.
    @inlinable public func mutate<Subject, Member, Value>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ value: inout Value, _ newValue: Value, _ isIdentityEqual: (Value, Value) -> Bool, _ shouldNotifyObservers: (Value, Value) -> Bool = { _, _ in true }) where Subject : Observable

    /// A no-op for non-observable values.
    ///
    /// See ``willModify(_:keyPath:_:)-29op6`` info on what this method does when used with
    /// observable values.
    @inlinable public func willModify<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ member: inout Member) -> Member where Subject : Observable

    /// A property observation called before setting the value of the subject.
    ///
    /// - Parameters:
    ///   - subject: An instance of an observable type.`
    ///   - keyPath: The key path of an observed property.
    ///   - member: The value in the subject that will be set.
    @inlinable public func willModify<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ member: inout Member) -> Member where Subject : Observable, Member : ComposableArchitecture.ObservableState

    /// A property observation called after setting the value of the subject.
    ///
    /// If the identity of the value changed between ``willModify(_:keyPath:_:)-29op6`` and
    /// ``didModify(_:keyPath:_:_:_:)-34nhq``, observers are notified.
    @inlinable public func didModify<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ member: inout Member, _ oldValue: Member, _ isIdentityEqual: (Member, Member) -> Bool, _ shouldNotifyObservers: (Member, Member) -> Bool = { _, _ in true }) where Subject : Observable
}

extension ObservationStateRegistrar {

    @inlinable public func access<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>) where Subject : PerceptionCore.Perceptible

    @inlinable public func mutate<Subject, Member, Value>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ value: inout Value, _ newValue: Value, _ isIdentityEqual: (Value, Value) -> Bool, _ shouldNotifyObservers: (Value, Value) -> Bool = { _, _ in true }) where Subject : PerceptionCore.Perceptible

    @inlinable public func willModify<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ member: inout Member) -> Member where Subject : PerceptionCore.Perceptible

    @inlinable public func willModify<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ member: inout Member) -> Member where Subject : PerceptionCore.Perceptible, Member : ComposableArchitecture.ObservableState

    @inlinable public func didModify<Subject, Member>(_ subject: Subject, keyPath: KeyPath<Subject, Member>, _ member: inout Member, _ oldValue: Member, _ isIdentityEqual: (Member, Member) -> Bool, _ shouldNotifyObservers: (Member, Member) -> Bool = { _, _ in true }) where Subject : PerceptionCore.Perceptible
}

@attached(accessor, names: named(init), named(get), named(set)) @attached(peer, names: prefixed(`_`)) public macro ObservationStateTracked() = #externalMacro(module: "ComposableArchitectureMacros", type: "ObservationStateTrackedMacro")

/// A wrapper type for actions that can be presented.
///
/// Use this wrapper type for modeling a feature's domain that needs to present a child
/// feature using ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q``.
///
/// For example, if you have a `ChildFeature` reducer that encapsulates the logic and behavior
/// for a feature, then any feature that wants to present that feature will hold onto
/// `ChildFeature.Action` like so:
///
/// ```swift
/// @Reducer
/// struct ParentFeature {
///   // ...
///   enum Action {
///     case child(PresentationAction<ChildFeature.Action>)
///      // ...
///   }
///   // ...
/// }
/// ```
///
/// The ``PresentationAction`` enum has two cases that represent the two fundamental operations
/// you can do when presenting a child feature: ``PresentationAction/presented(_:)`` represents
/// an action happening _inside_ the child feature, and ``PresentationAction/dismiss`` represents
/// dismissing the child feature by `nil`-ing its state.
///
/// See the dedicated article on <doc:Navigation> for more information on the library's navigation
/// tools, and in particular see <doc:TreeBasedNavigation> for information on modeling navigation
/// using optionals and enums.
public enum PresentationAction<Action> {

    /// An action sent to `nil` out the associated presentation state.
    case dismiss

    /// An action sent to the associated, non-`nil` presentation state.
    indirect case presented(Action)
}

extension PresentationAction : CasePathsCore.CasePathable {

    /// A collection of all case paths of this type.
    public static var allCasePaths: ComposableArchitecture.PresentationAction<Action>.AllCasePaths { get }

    /// A type that can represent a collection of all case paths of this type.
    @dynamicMemberLookup public struct AllCasePaths {

        public var dismiss: CasePathsCore.AnyCasePath<ComposableArchitecture.PresentationAction<Action>, Void> { get }

        public var presented: CasePathsCore.AnyCasePath<ComposableArchitecture.PresentationAction<Action>, Action> { get }

        public subscript<AppendedAction>(dynamicMember keyPath: CasePathsCore.CaseKeyPath<Action, AppendedAction>) -> CasePathsCore.AnyCasePath<ComposableArchitecture.PresentationAction<Action>, AppendedAction> where Action : CasePathsCore.CasePathable { get }

        public subscript<AppendedAction>(dynamicMember keyPath: CasePathsCore.CaseKeyPath<Action, AppendedAction>) -> CasePathsCore.AnyCasePath<ComposableArchitecture.PresentationAction<Action>, ComposableArchitecture.PresentationAction<AppendedAction>> where Action : CasePathsCore.CasePathable { get }
    }
}

extension PresentationAction : Equatable where Action : Equatable {
}

extension PresentationAction : Hashable where Action : Hashable {
}

extension PresentationAction : Sendable where Action : Sendable {
}

extension PresentationAction : Decodable where Action : Decodable {
}

extension PresentationAction : Encodable where Action : Encodable {
}

/// A property wrapper for state that can be presented.
///
/// Use this property wrapper for modeling a feature's domain that needs to present a child feature
/// using ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q``.
///
/// For example, if you have a `ChildFeature` reducer that encapsulates the logic and behavior for a
/// feature, then any feature that wants to present that feature will hold onto `ChildFeature.State`
/// like so:
///
/// ```swift
/// @Reducer
/// struct ParentFeature {
///   struct State {
///     @PresentationState var child: ChildFeature.State?
///      // ...
///   }
///   // ...
/// }
/// ```
///
/// For the most part your feature's logic can deal with `child` as a plain optional value, but
/// there are times you need to know that you are secretly dealing with `PresentationState`. For
/// example, when using the ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` reducer operator to
/// integrate the parent and child features together, you will construct a key path to the projected
/// value `\.$child`:
///
/// ```swift
/// @Reducer
/// struct ParentFeature {
///   // ...
///   var body: some ReducerOf<Self> {
///     Reduce { state, action in
///       // Core logic for parent feature
///     }
///     .ifLet(\.$child, action: \.child) {
///       ChildFeature()
///     }
///   }
/// }
/// ```
///
/// See the dedicated article on <doc:Navigation> for more information on the library's navigation
/// tools, and in particular see <doc:TreeBasedNavigation> for information on modeling navigation
/// using optionals and enums.
@dynamicMemberLookup @propertyWrapper public struct PresentationState<State> {

    public init(wrappedValue: State?)

    public var wrappedValue: State?

    public var projectedValue: ComposableArchitecture.PresentationState<State>

    public subscript<Case>(dynamicMember keyPath: CasePathsCore.CaseKeyPath<State, Case>) -> ComposableArchitecture.PresentationState<Case> where State : CasePathsCore.CasePathable { get }

    public subscript<Member>(dynamicMember keyPath: KeyPath<State, Member>) -> ComposableArchitecture.PresentationState<Member> { get }

    /// Accesses the value associated with the given case for reading and writing.
    ///
    /// If you use the techniques of tree-based navigation (see <doc:TreeBasedNavigation>), then
    /// you will have a single enum that determines the destinations your feature can navigate to,
    /// and you will hold onto that state using the ``Presents()`` macro:
    ///
    /// ```swift
    /// @ObservableState
    /// struct State {
    ///   @Presents var destination: Destination.State
    /// }
    /// ```
    ///
    /// The `destination` property has a projected value of ``PresentationState``, which gives you a
    /// succinct syntax for modifying the data in a particular case of the `Destination` enum, like
    /// so:
    ///
    /// ```swift
    /// state.$destination[case: \.detail]?.alert = AlertState {
    ///   Text("Delete?")
    /// }
    /// ```
    ///
    /// > Important: Accessing the wrong case will result in a runtime warning and test failure.
    public subscript<Case>(case path: CasePathsCore.CaseKeyPath<State, Case>) -> Case? where State : CasePathsCore.CasePathable

    @available(iOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    public subscript<Case>(case path: CasePathsCore.AnyCasePath<State, Case>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> Case?
}

extension PresentationState : Equatable where State : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.PresentationState<State>, rhs: ComposableArchitecture.PresentationState<State>) -> Bool
}

extension PresentationState : Hashable where State : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension PresentationState : Sendable where State : Sendable {
}

extension PresentationState : Decodable where State : Decodable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

extension PresentationState : Encodable where State : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

extension PresentationState : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@MainActor public struct PresentationStore<State, Action, DestinationState, DestinationAction, Content> : View where Content : View {

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder content: @escaping (_ isPresented: Binding<Bool>, _ destination: ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content) where State == DestinationState, Action == DestinationAction

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder content: @escaping (_ item: Binding<ComposableArchitecture.AnyIdentifiable?>, _ destination: ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content) where State == DestinationState, Action == DestinationAction

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, @ViewBuilder content: @escaping (_ isPresented: Binding<Bool>, _ destination: ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content)

    @MainActor public init(_ store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, @ViewBuilder content: @escaping (_ item: Binding<ComposableArchitecture.AnyIdentifiable?>, _ destination: ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

/// Wraps a property with ``PresentationState`` and observes it.
///
/// Use this macro instead of ``PresentationState`` when you adopt the ``ObservableState()``
/// macro, which is incompatible with property wrappers like ``PresentationState``.
@attached(accessor, names: named(init), named(get), named(set)) @attached(peer, names: prefixed(`$`), prefixed(`_`)) public macro Presents() = #externalMacro(module: "ComposableArchitectureMacros", type: "PresentsMacro")

/// A type-erased reducer that invokes the given `reduce` function.
///
/// ``Reduce`` is useful for injecting logic into a reducer tree without the overhead of introducing
/// a new type that conforms to ``Reducer``.
public struct Reduce<State, Action> : ComposableArchitecture.Reducer {

    /// Initializes a reducer with a `reduce` function.
    ///
    /// - Parameter reduce: A function that is called when ``reduce(into:action:)`` is invoked.
    @inlinable public init(_ reduce: @escaping (_ state: inout State, _ action: Action) -> ComposableArchitecture.Effect<Action>)

    /// Type-erases a reducer.
    ///
    /// - Parameter reducer: A reducer that is called when ``reduce(into:action:)`` is invoked.
    @inlinable public init(_ reducer: some ComposableArchitecture.Reducer<State, Action>)

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout State, action: Action) -> ComposableArchitecture.Effect<Action>
}

/// A protocol that describes how to evolve the current state of an application to the next state,
/// given an action, and describes what ``Effect``s should be executed later by the store, if any.
public protocol Reducer<State, Action> {

    /// A type that holds the current state of the reducer.
    associatedtype State

    /// A type that holds all possible actions that cause the ``State`` of the reducer to change
    /// and/or kick off a side ``Effect`` that can communicate with the outside world.
    associatedtype Action

    /// A type representing the body of this reducer.
    ///
    /// When you create a custom reducer by implementing the ``body-swift.property``, Swift infers
    /// this type from the value returned.
    ///
    /// If you create a custom reducer by implementing the ``reduce(into:action:)-1t2ri``, Swift
    /// infers this type to be `Never`.
    associatedtype Body

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    func reduce(into state: inout Self.State, action: Self.Action) -> ComposableArchitecture.Effect<Self.Action>

    /// The content and behavior of a reducer that is composed from other reducers.
    ///
    /// In the body of a reducer one can compose many reducers together, which will be run in order,
    /// from top to bottom, and usually involves some reducer operations for integrating, such as
    /// `ifLet`, `forEach`, `_printChanges`, etc.:
    ///
    /// ```swift
    /// var body: some ReducerOf<Self> {
    ///   Reduce { state, action in
    ///     â€¦
    ///   }
    ///   .ifLet(\.child, action: \.child) {
    ///     ChildFeature()
    ///   }
    ///   ._printChanges()
    ///
    ///   Analytics()
    /// }
    /// ```
    ///
    /// Do not invoke this property directly.
    ///
    /// > Important: if your reducer implements the ``reduce(into:action:)-1t2ri`` method, it will
    /// > take precedence over this property, and only ``reduce(into:action:)-1t2ri`` will be called
    /// > by the ``Store``. If your reducer assembles a body from other reducers and has additional
    /// > business logic it needs to layer into the system, introduce this logic into the body
    /// > instead, either with ``Reduce``, or with a separate, dedicated conformance.
    @ComposableArchitecture.ReducerBuilder<Self.State, Self.Action> var body: Self.Body { get }
}

extension Reducer {

    /// A special overload of ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` for enum
    /// reducers.
    public func ifLet<ChildState, ChildAction>(_ state: WritableKeyPath<Self.State, ComposableArchitecture.PresentationState<ChildState>>, action: CasePathsCore.CaseKeyPath<Self.Action, ComposableArchitecture.PresentationAction<ChildAction>>) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where ChildState : ComposableArchitecture.CaseReducerState, ChildAction == ChildState.StateReducer.Action


    /// A special overload of ``Reducer/forEach(_:action:destination:fileID:filePath:line:column:)-9svqb`` for enum
    /// reducers.
    public func forEach<DestinationState, DestinationAction>(_ state: WritableKeyPath<Self.State, ComposableArchitecture.StackState<DestinationState>>, action: CasePathsCore.CaseKeyPath<Self.Action, ComposableArchitecture.StackAction<DestinationState, DestinationAction>>) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState : ComposableArchitecture.CaseReducerState, DestinationAction == DestinationState.StateReducer.Action

}

extension Reducer where Self.Body == Never {

    /// A non-existent body.
    ///
    /// > Warning: Do not invoke this property directly. It will trigger a fatal error at runtime.
    public var body: Never { get }
}

extension Reducer where Self.Action == Self.Body.Action, Self.Body : ComposableArchitecture.Reducer, Self.State == Self.Body.State {

    /// Invokes the ``Body-40qdd``'s implementation of ``reduce(into:action:)-1t2ri``.
    @inlinable public func reduce(into state: inout Self.Body.State, action: Self.Body.Action) -> ComposableArchitecture.Effect<Self.Body.Action>
}

extension Reducer {

    /// Enhances a reducer with debug logging of received actions and state mutations for the given
    /// printer.
    ///
    /// > Note: Printing is only done in `DEBUG` configurations.
    ///
    /// - Parameter printer: A printer for printing debug messages.
    /// - Returns: A reducer that prints debug messages for all received actions.
    @warn_unqualified_access
    @inlinable public func _printChanges(_ printer: ComposableArchitecture._ReducerPrinter<Self.State, Self.Action>? = .customDump) -> ComposableArchitecture._PrintChangesReducer<Self>
}

extension Reducer {

    /// Sets the dependency value of the specified key path to the given value.
    ///
    /// This overrides the dependency specified by `keyPath` for the execution of the receiving
    /// reducer _and_ all of its effects. It can be useful for altering the dependencies for just
    /// one portion of your application, while letting the rest of the application continue using the
    /// default live dependencies.
    ///
    /// For example, suppose you are creating an onboarding experience to teach people how to use one
    /// of your features. This can be done by constructing a new reducer that embeds the core
    /// feature's domain and layers on additional logic:
    ///
    /// ```swift
    /// @Reducer
    /// struct Onboarding {
    ///   struct State {
    ///     var feature: Feature.State
    ///     // Additional onboarding state
    ///   }
    ///   enum Action {
    ///     case feature(Feature.Action)
    ///     // Additional onboarding actions
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     Scope(state: \.feature, action: \.feature) {
    ///       Feature()
    ///     }
    ///
    ///     Reduce { state, action in
    ///       // Additional onboarding logic
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// This can work just fine, but the `Feature` reducer will have access to all of the live
    /// dependencies by default, and that might not be ideal. For example, the `Feature` reducer
    /// may need to make API requests and read/write from user defaults. It may be preferable
    /// to run the `Feature` reducer in an alternative environment for onboarding purposes, such
    /// as an API client that returns some mock data or an in-memory user defaults so that the
    /// onboarding experience doesn't accidentally trample on shared data.
    ///
    /// This can be by using the ``dependency(_:_:)`` method to override those dependencies
    /// just for the `Feature` reducer and its effects:
    ///
    /// ```swift
    /// var body: some Reducer<State, Action> {
    ///   Scope(state: \.feature, action: \.feature) {
    ///     Feature()
    ///       .dependency(\.apiClient, .mock)
    ///       .dependency(\.userDefaults, .mock)
    ///   }
    ///
    ///   Reduce { state, action in
    ///     // Additional onboarding logic
    ///   }
    /// }
    /// ```
    ///
    /// See ``transformDependency(_:transform:)`` for a similar method that can inspect and modify the
    /// current dependency when overriding.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the `DependencyValues` structure to
    ///     update.
    ///   - value: The new value to set for the item specified by `keyPath`.
    /// - Returns: A reducer that has the given value set in its dependencies.
    @warn_unqualified_access
    @inlinable public func dependency<Value>(_ keyPath: WritableKeyPath<Dependencies.DependencyValues, Value>, _ value: Value) -> ComposableArchitecture._DependencyKeyWritingReducer<Self>

    /// Places a value in the reducer's dependencies.
    ///
    /// - Parameter value: The value to set for this value's type in the dependencies.
    /// - Returns: A reducer that has the given value set in its dependencies.
    @warn_unqualified_access
    @inlinable public func dependency<Value>(_ value: Value) -> ComposableArchitecture._DependencyKeyWritingReducer<Self> where Value : Dependencies.TestDependencyKey, Value == Value.Value

    /// Transform a reducer's dependency value at the specified key path with the given function.
    ///
    /// This is similar to ``dependency(_:_:)``, except it allows you to mutate a dependency value
    /// directly. This can be handy when you want to alter a dependency but still use its current
    /// value.
    ///
    /// For example, suppose you want to see when a particular endpoint of a dependency gets called
    /// in your application. You can override that endpoint to insert a breakpoint or print statement,
    /// but still call out to the original endpoint:
    ///
    /// ```swift
    ///   Feature()
    ///     .transformDependency(\.speechClient) { speechClient in
    ///       speechClient.requestAuthorization = {
    ///         print("requestAuthorization")
    ///         try await speechClient.requestAuthorization()
    ///       }
    ///     }
    /// ```
    ///
    /// You can also transform _all_ dependency values at once by using the `\.self` key path:
    ///
    /// ```swift
    /// Feature()
    ///   .transformDependency(\.self) { dependencyValues in
    ///     // Access to all dependencies in here
    ///   }
    /// ```
    ///
    /// > Warning: The trailing closure of ``transformDependency(_:transform:)`` is called for every
    /// action sent to the reducer, and so you can expect it to be called many times in an
    /// application's lifecycle. This means you should typically not create dependencies in the
    /// closure as that will cause a new dependency to be created everytime an action is sent.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the `DependencyValues` structure to
    ///     transform.
    ///   - transform: A closure that is handed a mutable instance of the value specified by the key
    ///     path.
    @warn_unqualified_access
    @inlinable public func transformDependency<V>(_ keyPath: WritableKeyPath<Dependencies.DependencyValues, V>, transform: @escaping (_ dependency: inout V) -> Void) -> ComposableArchitecture._DependencyKeyWritingReducer<Self>
}

extension Reducer {

    /// Embeds a child reducer in a parent domain that works on elements of a collection in parent
    /// state.
    ///
    /// For example, if a parent feature holds onto an array of child states, then it can perform
    /// its core logic _and_ the child's logic by using the `forEach` operator:
    ///
    /// ```swift
    /// @Reducer
    /// struct Parent {
    ///   struct State {
    ///     var rows: IdentifiedArrayOf<Row.State>
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case rows(IdentifiedActionOf<Row>)
    ///     // ...
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     Reduce { state, action in
    ///       // Core logic for parent feature
    ///     }
    ///     .forEach(\.rows, action: \.rows) {
    ///       Row()
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// > Tip: We are using `IdentifiedArray` from our
    /// [Identified Collections][swift-identified-collections] library because it provides a safe
    /// and ergonomic API for accessing elements from a stable ID rather than positional indices.
    ///
    /// The `forEach` forces a specific order of operations for the child and parent features. It
    /// runs the child first, and then the parent. If the order was reversed, then it would be
    /// possible for the parent feature to remove the child state from the array, in which case the
    /// child feature would not be able to react to that action. That can cause subtle bugs.
    ///
    /// It is still possible for a parent feature higher up in the application to remove the child
    /// state from the array before the child has a chance to react to the action. In such cases a
    /// runtime warning is shown in Xcode to let you know that there's a potential problem.
    ///
    /// [swift-identified-collections]: http://github.com/pointfreeco/swift-identified-collections
    ///
    /// - Parameters:
    ///   - toElementsState: A writable key path from parent state to an `IdentifiedArray` of child
    ///     state.
    ///   - toElementAction: A case path from parent action to an ``IdentifiedAction`` of child
    ///     actions.
    ///   - element: A reducer that will be invoked with child actions against elements of child
    ///     state.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A reducer that combines the child reducer with the parent reducer.
    @warn_unqualified_access
    @inlinable public func forEach<ElementState, ElementAction, ID, Element>(_ toElementsState: WritableKeyPath<Self.State, IdentifiedCollections.IdentifiedArray<ID, ElementState>>, action toElementAction: CasePathsCore.CaseKeyPath<Self.Action, ComposableArchitecture.IdentifiedAction<ID, ElementAction>>, @ComposableArchitecture.ReducerBuilder<ElementState, ElementAction> element: () -> Element, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where ElementState == Element.State, ElementAction == Element.Action, ID : Hashable, ID : Sendable, Element : ComposableArchitecture.Reducer


    @available(iOS, deprecated: 9999, message: "Use a case key path to an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4")
    @available(macOS, deprecated: 9999, message: "Use a case key path to an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4")
    @available(tvOS, deprecated: 9999, message: "Use a case key path to an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4")
    @available(watchOS, deprecated: 9999, message: "Use a case key path to an 'IdentifiedAction', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4")
    @warn_unqualified_access
    @inlinable public func forEach<ElementState, ElementAction, ID, Element>(_ toElementsState: WritableKeyPath<Self.State, IdentifiedCollections.IdentifiedArray<ID, ElementState>>, action toElementAction: CasePathsCore.AnyCasePath<Self.Action, (ID, ElementAction)>, @ComposableArchitecture.ReducerBuilder<ElementState, ElementAction> element: () -> Element, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where ElementState == Element.State, ElementAction == Element.Action, ID : Hashable, ID : Sendable, Element : ComposableArchitecture.Reducer

}

extension Reducer {

    /// Embeds a child reducer in a parent domain that works on a case of parent enum state.
    ///
    /// For example, if a parent feature's state is expressed as an enum of multiple children
    /// states, then `ifCaseLet` can run a child reducer on a particular case of the enum:
    ///
    /// ```swift
    /// @Reducer
    /// struct Parent {
    ///   enum State {
    ///     case loggedIn(Authenticated.State)
    ///     case loggedOut(Unauthenticated.State)
    ///   }
    ///   enum Action {
    ///     case loggedIn(Authenticated.Action)
    ///     case loggedOut(Unauthenticated.Action)
    ///     // ...
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     Reduce { state, action in
    ///       // Core logic for parent feature
    ///     }
    ///     .ifCaseLet(\.loggedIn, action: \.loggedIn) {
    ///       Authenticated()
    ///     }
    ///     .ifCaseLet(\.loggedOut, action: \.loggedOut) {
    ///       Unauthenticated()
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// The `ifCaseLet` operator does a number of things to try to enforce correctness:
    ///
    ///   * It forces a specific order of operations for the child and parent features. It runs the
    ///     child first, and then the parent. If the order was reversed, then it would be possible for
    ///     the parent feature to change the case of the child enum, in which case the child
    ///     feature would not be able to react to that action. That can cause subtle bugs.
    ///
    ///   * It automatically cancels all child effects when it detects the child enum case changes.
    ///
    /// It is still possible for a parent feature higher up in the application to change the case of
    /// the enum before the child has a chance to react to the action. In such cases a runtime
    /// warning is shown in Xcode to let you know that there's a potential problem.
    ///
    /// - Parameters:
    ///   - toCaseState: A case path from parent state to a case containing child state.
    ///   - toCaseAction: A case path from parent action to a case containing child actions.
    ///   - case: A reducer that will be invoked with child actions against child state when it is
    ///     present
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A reducer that combines the child reducer with the parent reducer.
    @warn_unqualified_access
    @inlinable public func ifCaseLet<CaseState, CaseAction, Case>(_ toCaseState: CasePathsCore.CaseKeyPath<Self.State, CaseState>, action toCaseAction: CasePathsCore.CaseKeyPath<Self.Action, CaseAction>, @ComposableArchitecture.ReducerBuilder<CaseState, CaseAction> then case: () -> Case, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> ComposableArchitecture._IfCaseLetReducer<Self, Case> where CaseState == Case.State, CaseAction == Case.Action, Case : ComposableArchitecture.Reducer, Self.Action : CasePathsCore.CasePathable, Self.State : CasePathsCore.CasePathable

    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @warn_unqualified_access
    @inlinable public func ifCaseLet<CaseState, CaseAction, Case>(_ toCaseState: CasePathsCore.AnyCasePath<Self.State, CaseState>, action toCaseAction: CasePathsCore.AnyCasePath<Self.Action, CaseAction>, @ComposableArchitecture.ReducerBuilder<CaseState, CaseAction> then case: () -> Case, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where CaseState == Case.State, CaseAction == Case.Action, Case : ComposableArchitecture.Reducer

}

extension Reducer {

    /// Embeds a child reducer in a parent domain that works on an optional property of parent state.
    ///
    /// For example, if a parent feature holds onto a piece of optional child state, then it can
    /// perform its core logic _and_ the child's logic by using the `ifLet` operator:
    ///
    /// ```swift
    /// @Reducer
    /// struct Parent {
    ///   struct State {
    ///     var child: Child.State?
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case child(Child.Action)
    ///     // ...
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     Reduce { state, action in
    ///       // Core logic for parent feature
    ///     }
    ///     .ifLet(\.child, action: \.child) {
    ///       Child()
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// The `ifLet` operator does a number of things to try to enforce correctness:
    ///
    ///   * It forces a specific order of operations for the child and parent features. It runs the
    ///     child first, and then the parent. If the order was reversed, then it would be possible for
    ///     the parent feature to `nil` out the child state, in which case the child feature would not
    ///     be able to react to that action. That can cause subtle bugs.
    ///
    ///   * It automatically cancels all child effects when it detects the child's state is `nil`'d
    ///     out.
    ///
    ///   * Automatically `nil`s out child state when an action is sent for alerts and confirmation
    ///     dialogs.
    ///
    /// See ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` for a more advanced operator suited
    /// to navigation.
    ///
    /// - Parameters:
    ///   - toWrappedState: A writable key path from parent state to a property containing optional
    ///     child state.
    ///   - toWrappedAction: A case path from parent action to a case containing child actions.
    ///   - wrapped: A reducer that will be invoked with child actions against non-optional child
    ///     state.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A reducer that combines the child reducer with the parent reducer.
    @warn_unqualified_access
    @inlinable public func ifLet<WrappedState, WrappedAction, Wrapped>(_ toWrappedState: WritableKeyPath<Self.State, WrappedState?>, action toWrappedAction: CasePathsCore.CaseKeyPath<Self.Action, WrappedAction>, @ComposableArchitecture.ReducerBuilder<WrappedState, WrappedAction> then wrapped: () -> Wrapped, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where WrappedState == Wrapped.State, WrappedAction == Wrapped.Action, Wrapped : ComposableArchitecture.Reducer


    /// A special overload of ``Reducer/ifLet(_:action:then:fileID:filePath:line:column:)-2r2pn``
    /// for alerts and confirmation dialogs that does not require a child reducer.
    @warn_unqualified_access
    @inlinable public func ifLet<WrappedState, WrappedAction>(_ toWrappedState: WritableKeyPath<Self.State, WrappedState?>, action toWrappedAction: CasePathsCore.CaseKeyPath<Self.Action, WrappedAction>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where WrappedState : ComposableArchitecture._EphemeralState


    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @warn_unqualified_access
    @inlinable public func ifLet<WrappedState, WrappedAction, Wrapped>(_ toWrappedState: WritableKeyPath<Self.State, WrappedState?>, action toWrappedAction: CasePathsCore.AnyCasePath<Self.Action, WrappedAction>, @ComposableArchitecture.ReducerBuilder<WrappedState, WrappedAction> then wrapped: () -> Wrapped, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where WrappedState == Wrapped.State, WrappedAction == Wrapped.Action, Wrapped : ComposableArchitecture.Reducer


    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @warn_unqualified_access
    @inlinable public func ifLet<WrappedState, WrappedAction>(_ toWrappedState: WritableKeyPath<Self.State, WrappedState?>, action toWrappedAction: CasePathsCore.AnyCasePath<Self.Action, WrappedAction>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> ComposableArchitecture._IfLetReducer<Self, ComposableArchitecture.EmptyReducer<WrappedState, WrappedAction>> where WrappedState : ComposableArchitecture._EphemeralState
}

extension Reducer {

    /// Adds a reducer to run when this reducer changes the given value in state.
    ///
    /// Use this operator to trigger additional logic when a value changes, like when a
    /// ``BindingReducer`` makes a deeper change to a struct held in ``BindingState``.
    ///
    /// ```swift
    /// @Reducer
    /// struct Settings {
    ///   struct State {
    ///     @BindingState var userSettings: UserSettings
    ///     // ...
    ///   }
    ///
    ///   enum Action: BindableAction {
    ///     case binding(BindingAction<State>)
    ///     // ...
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     BindingReducer()
    ///       .onChange(
    ///         of: { ($0.userSettings.isHapticFeedbackEnabled, $0.userSettings.isPushEnabled) },
    ///         removeDuplicates: ==
    ///       ) { oldValue, newValue in
    ///         Reduce { state, action in
    ///           .run { send in
    ///             // Persist new value...
    ///           }
    ///         }
    ///       }
    ///   }
    /// }
    /// ```
    ///
    /// When the value changes, the new version of the closure will be called, so any captured values
    /// will have their values from the time that the observed value has its new value. The system
    /// passes the old and new observed values into the closure.
    ///
    /// > Note: Take care when applying `onChange(of:)` to a reducer, as it adds an equatable check
    /// > for every action fed into it. Prefer applying it to leaf nodes, like ``BindingReducer``,
    /// > against values that are quick to equate.
    ///
    /// - Parameters:
    ///   - toValue: A closure that returns a value from the given state.
    ///   - isDuplicate: A closure to evaluate whether two elements are equivalent, for purposes of
    ///     filtering. Return `true` from this closure to indicate that the second element is a
    ///     duplicate of the first.
    ///   - reducer: A reducer builder closure to run when the value changes.
    ///     - oldValue: The old value that failed the comparison check.
    ///     - newValue: The new value that failed the comparison check.
    /// - Returns: A reducer that performs the logic when the state changes.
    @available(*, deprecated, message: "Use 'onChange(of:)' with and equatable value, instead.")
    @inlinable public func onChange<V, R>(of toValue: @escaping (Self.State) -> V, removeDuplicates isDuplicate: @escaping (V, V) -> Bool, @ComposableArchitecture.ReducerBuilder<Self.State, Self.Action> _ reducer: @escaping (_ oldValue: V, _ newValue: V) -> R) -> ComposableArchitecture._OnChangeReducer<Self, V, R> where R : ComposableArchitecture.Reducer, Self.Action == R.Action, Self.State == R.State

    /// Adds a reducer to run when this reducer changes the given value in state.
    ///
    /// > Important: The `onChange` operator is only capable of detecting changes made by the reducer
    /// > it is directly attached to. It does not observe changes that are made from other actions,
    /// > such as parent actions.
    ///
    /// Use this operator to trigger additional logic when a value changes, like when a
    /// ``BindingReducer`` makes a deeper change to a struct held in ``BindingState``.
    ///
    /// ```swift
    /// @Reducer
    /// struct Settings {
    ///   struct State {
    ///     @BindingState var userSettings: UserSettings
    ///     // ...
    ///   }
    ///
    ///   enum Action: BindableAction {
    ///     case binding(BindingAction<State>)
    ///     // ...
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     BindingReducer()
    ///       .onChange(of: \.userSettings.isHapticFeedbackEnabled) { oldValue, newValue in
    ///         Reduce { state, action in
    ///           .run { send in
    ///             // Persist new value...
    ///           }
    ///         }
    ///       }
    ///   }
    /// }
    /// ```
    ///
    /// When the value changes, the new version of the closure will be called, so any captured values
    /// will have their values from the time that the observed value has its new value. The system
    /// passes the old and new observed values into the closure.
    ///
    /// > Note: Take care when applying `onChange(of:)` to a reducer, as it adds an equatable check
    /// > for every action fed into it. Prefer applying it to leaf nodes, like ``BindingReducer``,
    /// > against values that are quick to equate.
    ///
    /// - Parameters:
    ///   - toValue: A closure that returns a value from the given state.
    ///   - reducer: A reducer builder closure to run when the value changes.
    ///     - `oldValue`: The old value that failed the comparison check.
    ///     - `newValue`: The new value that failed the comparison check.
    /// - Returns: A reducer that performs the logic when the state changes.
    @inlinable public func onChange<V, R>(of toValue: @escaping (Self.State) -> V, @ComposableArchitecture.ReducerBuilder<Self.State, Self.Action> _ reducer: @escaping (_ oldValue: V, _ newValue: V) -> R) -> ComposableArchitecture._OnChangeReducer<Self, V, R> where V : Equatable, R : ComposableArchitecture.Reducer, Self.Action == R.Action, Self.State == R.State
}

extension Reducer {

    /// Embeds a child reducer in a parent domain that works on an optional property of parent state.
    ///
    /// This version of `ifLet` requires the usage of the ``Presents()`` macro and
    /// ``PresentationAction`` type in your feature's domain.
    ///
    /// For example, if a parent feature holds onto a piece of optional child state, then it can
    /// perform its core logic _and_ the child's logic by using the `ifLet` operator:
    ///
    /// ```swift
    /// @Reducer
    /// struct Parent {
    ///   @ObservableState
    ///   struct State {
    ///     @Presents var child: Child.State?
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case child(PresentationAction<Child.Action>)
    ///     // ...
    ///   }
    ///
    ///   var body: some ReducerOf<Self> {
    ///     Reduce { state, action in
    ///       // Core logic for parent feature
    ///     }
    ///     .ifLet(\.$child, action: \.child) {
    ///       Child()
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// The `ifLet` operator does a number of things to make integrating parent and child features
    /// ergonomic and enforce correctness:
    ///
    ///   * It forces a specific order of operations for the child and parent features:
    ///     * When a ``PresentationAction/dismiss`` action is sent, it runs the parent feature
    ///       before the child state is `nil`'d out. This gives the parent feature an opportunity to
    ///       inspect the child state one last time before the state is cleared.
    ///     * When a ``PresentationAction/presented(_:)`` action is sent it runs the
    ///       child first, and then the parent. If the order was reversed, then it would be possible
    ///       for the parent feature to `nil` out the child state, in which case the child feature
    ///       would not be able to react to that action. That can cause subtle bugs.
    ///
    ///   * It automatically cancels all child effects when it detects the child's state is `nil`'d
    ///     out.
    ///
    ///   * Automatically `nil`s out child state when an action is sent for alerts and confirmation
    ///     dialogs.
    ///
    ///   * It gives the child feature access to the ``DismissEffect`` dependency, which allows the
    ///     child feature to dismiss itself without communicating with the parent.
    ///
    /// - Parameters:
    ///   - toPresentationState: A writable key path from parent state to a property containing child
    ///     presentation state.
    ///   - toPresentationAction: A case path from parent action to a case containing child actions.
    ///   - destination: A reducer that will be invoked with child actions against presented child
    ///     state.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A reducer that combines the child reducer with the parent reducer.
    @warn_unqualified_access
    @inlinable public func ifLet<DestinationState, DestinationAction, Destination>(_ toPresentationState: WritableKeyPath<Self.State, ComposableArchitecture.PresentationState<DestinationState>>, action toPresentationAction: CasePathsCore.CaseKeyPath<Self.Action, ComposableArchitecture.PresentationAction<DestinationAction>>, @ComposableArchitecture.ReducerBuilder<DestinationState, DestinationAction> destination: () -> Destination, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState == Destination.State, DestinationAction == Destination.Action, Destination : ComposableArchitecture.Reducer


    /// A special overload of ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` for alerts
    /// and confirmation dialogs that does not require a child reducer.
    @warn_unqualified_access
    @inlinable public func ifLet<DestinationState, DestinationAction>(_ toPresentationState: WritableKeyPath<Self.State, ComposableArchitecture.PresentationState<DestinationState>>, action toPresentationAction: CasePathsCore.CaseKeyPath<Self.Action, ComposableArchitecture.PresentationAction<DestinationAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState : ComposableArchitecture._EphemeralState


    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @warn_unqualified_access
    @inlinable public func ifLet<DestinationState, DestinationAction, Destination>(_ toPresentationState: WritableKeyPath<Self.State, ComposableArchitecture.PresentationState<DestinationState>>, action toPresentationAction: CasePathsCore.AnyCasePath<Self.Action, ComposableArchitecture.PresentationAction<DestinationAction>>, @ComposableArchitecture.ReducerBuilder<DestinationState, DestinationAction> destination: () -> Destination, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState == Destination.State, DestinationAction == Destination.Action, Destination : ComposableArchitecture.Reducer


    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @warn_unqualified_access
    @inlinable public func ifLet<DestinationState, DestinationAction>(_ toPresentationState: WritableKeyPath<Self.State, ComposableArchitecture.PresentationState<DestinationState>>, action toPresentationAction: CasePathsCore.AnyCasePath<Self.Action, ComposableArchitecture.PresentationAction<DestinationAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState : ComposableArchitecture._EphemeralState

}

extension Reducer {

    /// Instruments a reducer with
    /// [signposts](https://developer.apple.com/documentation/os/logging/recording_performance_data).
    ///
    /// Each invocation of the reducer will be measured by an interval, and the lifecycle of its
    /// effects will be measured with interval and event signposts.
    ///
    /// To use, build your app for profiling, create a blank instrument, and add the signpost
    /// instrument. Start recording your app you will see timing information for every action sent to
    /// the store, as well as every effect executed.
    ///
    /// Effect instrumentation can be particularly useful for inspecting the lifecycle of long-living
    /// effects. For example, if you start an effect (_e.g._, a location manager) in `onAppear` and
    /// forget to tear down the effect in `onDisappear`, the instrument will show that the effect
    /// never completed.
    ///
    /// - Parameters:
    ///   - prefix: A string to print at the beginning of the formatted message for the signpost.
    ///   - log: An `OSLog` to use for signposts.
    /// - Returns: A reducer that has been enhanced with instrumentation.
    @warn_unqualified_access
    @inlinable public func signpost(_ prefix: String = "", log: OSLog = OSLog(
      subsystem: "co.pointfree.ComposableArchitecture",
      category: "Reducer Instrumentation"
    )) -> ComposableArchitecture._SignpostReducer<Self>
}

extension Reducer {

    /// Embeds a child reducer in a parent domain that works on elements of a navigation stack in
    /// parent state.
    ///
    /// This version of `forEach` works when the parent domain holds onto the child domain using
    /// ``StackState`` and ``StackAction``.
    ///
    /// For example, if a parent feature models a navigation stack of child features using the
    /// ``StackState`` and ``StackAction`` types, then it can perform its core logic _and_ the logic
    /// of each child feature using the `forEach` operator:
    ///
    /// ```swift
    /// @Reducer
    /// struct ParentFeature {
    ///   struct State {
    ///     var path = StackState<Path.State>()
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case path(StackActionOf<Path>)
    ///     // ...
    ///   }
    ///   var body: some ReducerOf<Self> {
    ///     Reduce { state, action in
    ///       // Core parent logic
    ///     }
    ///     .forEach(\.path, action: \.path) {
    ///       Path()
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// The `forEach` operator does a number of things to make integrating parent and child features
    /// ergonomic and enforce correctness:
    ///
    ///   * It forces a specific order of operations for the child and parent features:
    ///     * When a ``StackAction/element(id:action:)`` action is sent it runs the
    ///       child first, and then the parent. If the order was reversed, then it would be possible
    ///       for the parent feature to `nil` out the child state, in which case the child feature
    ///       would not be able to react to that action. That can cause subtle bugs.
    ///     * When a ``StackAction/popFrom(id:)`` action is sent it runs the parent feature
    ///       before the child state is popped off the stack. This gives the parent feature an
    ///       opportunity to inspect the child state one last time before the state is removed.
    ///     * When a ``StackAction/push(id:state:)`` action is sent it runs the parent feature
    ///       after the child state is appended to the stack. This gives the parent feature an
    ///       opportunity to make extra mutations to the state after it has been added.
    ///
    ///   * It automatically cancels all child effects when it detects the child's state is removed
    ///     from the stack
    ///
    ///   * It gives the child feature access to the ``DismissEffect`` dependency, which allows the
    ///     child feature to dismiss itself without communicating with the parent.
    ///
    /// - Parameters:
    ///   - toStackState: A writable key path from parent state to a stack of destination state.
    ///   - toStackAction: A case path from parent action to a stack action.
    ///   - destination: A reducer that will be invoked with destination actions against elements of
    ///     destination state.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A reducer that combines the destination reducer with the parent reducer.
    @warn_unqualified_access
    @inlinable public func forEach<DestinationState, DestinationAction, Destination>(_ toStackState: WritableKeyPath<Self.State, ComposableArchitecture.StackState<DestinationState>>, action toStackAction: CasePathsCore.CaseKeyPath<Self.Action, ComposableArchitecture.StackAction<DestinationState, DestinationAction>>, @ComposableArchitecture.ReducerBuilder<DestinationState, DestinationAction> destination: () -> Destination, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState == Destination.State, DestinationAction == Destination.Action, Destination : ComposableArchitecture.Reducer


    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @warn_unqualified_access
    @inlinable public func forEach<DestinationState, DestinationAction, Destination>(_ toStackState: WritableKeyPath<Self.State, ComposableArchitecture.StackState<DestinationState>>, action toStackAction: CasePathsCore.AnyCasePath<Self.Action, ComposableArchitecture.StackAction<DestinationState, DestinationAction>>, @ComposableArchitecture.ReducerBuilder<DestinationState, DestinationAction> destination: () -> Destination, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some ComposableArchitecture.Reducer<Self.State, Self.Action> where DestinationState == Destination.State, DestinationAction == Destination.Action, Destination : ComposableArchitecture.Reducer

}

/// Helps implement the conformance to the ``Reducer`` protocol for a type.
///
/// See the article <doc:Reducer> for more information about the macro and ``Reducer`` protocol.
@attached(member, names: named(State), named(Action), named(init), named(body), named(CaseScope), named(scope)) @attached(memberAttribute) @attached(extension, conformances: ComposableArchitecture.Reducer, ComposableArchitecture.CaseReducer) public macro Reducer() = #externalMacro(module: "ComposableArchitectureMacros", type: "ReducerMacro")

/// An overload of ``Reducer()`` that takes a description of protocol conformances to synthesize on
/// the State and Action types
///
/// See the article <doc:Reducer> for more information about the macro and ``Reducer`` protocol, in
/// particular the section
/// <doc:Reducer#Synthesizing-protocol-conformances-on-State-and-Action>.
@available(*, deprecated, message: "Define your conformance using an extension, instead")
@attached(member, names: named(State), named(Action), named(init), named(body), named(CaseScope), named(scope)) @attached(memberAttribute) @attached(extension, conformances: ComposableArchitecture.Reducer, ComposableArchitecture.CaseReducer) public macro Reducer(state: ComposableArchitecture._SynthesizedConformance..., action: ComposableArchitecture._SynthesizedConformance...) = #externalMacro(module: "ComposableArchitectureMacros", type: "ReducerMacro")

/// A result builder for combining reducers into a single reducer by running each, one after the
/// other, and merging their effects.
///
/// It is most common to encounter a reducer builder context when conforming a type to ``Reducer``
/// and implementing its ``Reducer/body-swift.property`` property.
///
/// See ``CombineReducers`` for an entry point into a reducer builder context.
@resultBuilder public enum ReducerBuilder<State, Action> {

    @inlinable public static func buildArray(_ reducers: [some ComposableArchitecture.Reducer<State, Action>]) -> some ComposableArchitecture.Reducer<State, Action>


    @inlinable public static func buildBlock() -> some ComposableArchitecture.Reducer<State, Action>


    @inlinable public static func buildBlock<R>(_ reducer: R) -> R where State == R.State, Action == R.Action, R : ComposableArchitecture.Reducer

    @inlinable public static func buildEither<R0, R1>(first reducer: R0) -> ComposableArchitecture.ReducerBuilder<State, Action>._Conditional<R0, R1> where State == R0.State, Action == R0.Action, R0 : ComposableArchitecture.Reducer, R1 : ComposableArchitecture.Reducer, R0.Action == R1.Action, R0.State == R1.State

    @inlinable public static func buildEither<R0, R1>(second reducer: R1) -> ComposableArchitecture.ReducerBuilder<State, Action>._Conditional<R0, R1> where State == R0.State, Action == R0.Action, R0 : ComposableArchitecture.Reducer, R1 : ComposableArchitecture.Reducer, R0.Action == R1.Action, R0.State == R1.State

    @inlinable public static func buildExpression<R>(_ expression: R) -> R where State == R.State, Action == R.Action, R : ComposableArchitecture.Reducer

    @inlinable public static func buildExpression(_ expression: any ComposableArchitecture.Reducer<State, Action>) -> ComposableArchitecture.Reduce<State, Action>

    @inlinable public static func buildFinalResult<R>(_ reducer: R) -> R where State == R.State, Action == R.Action, R : ComposableArchitecture.Reducer

    @inlinable public static func buildLimitedAvailability(_ wrapped: some ComposableArchitecture.Reducer<State, Action>) -> ComposableArchitecture.Reduce<State, Action>

    @inlinable public static func buildOptional<R>(_ wrapped: R?) -> R? where State == R.State, Action == R.Action, R : ComposableArchitecture.Reducer

    @inlinable public static func buildPartialBlock<R>(first: R) -> R where State == R.State, Action == R.Action, R : ComposableArchitecture.Reducer

    @inlinable public static func buildPartialBlock<R0, R1>(accumulated: R0, next: R1) -> ComposableArchitecture.ReducerBuilder<State, Action>._Sequence<R0, R1> where State == R0.State, Action == R0.Action, R0 : ComposableArchitecture.Reducer, R1 : ComposableArchitecture.Reducer, R0.Action == R1.Action, R0.State == R1.State

    public enum _Conditional<First, Second> : ComposableArchitecture.Reducer where First : ComposableArchitecture.Reducer, Second : ComposableArchitecture.Reducer, First.Action == Second.Action, First.State == Second.State {

        case first(First)

        case second(Second)

        /// Evolves the current state of the reducer to the next state.
        ///
        /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
        /// features. To define a reducer by combining the logic of other reducers together, implement the
        /// ``body-swift.property`` requirement instead.
        ///
        /// - Parameters:
        ///   - state: The current state of the reducer.
        ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
        ///     side effect that can communicate with the outside world.
        /// - Returns: An effect that can communicate with the outside world and feed actions back into
        ///   the system.
        @inlinable public func reduce(into state: inout First.State, action: First.Action) -> ComposableArchitecture.Effect<First.Action>
    }

    public struct _Sequence<R0, R1> : ComposableArchitecture.Reducer where R0 : ComposableArchitecture.Reducer, R1 : ComposableArchitecture.Reducer, R0.Action == R1.Action, R0.State == R1.State {

        /// Evolves the current state of the reducer to the next state.
        ///
        /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
        /// features. To define a reducer by combining the logic of other reducers together, implement the
        /// ``body-swift.property`` requirement instead.
        ///
        /// - Parameters:
        ///   - state: The current state of the reducer.
        ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
        ///     side effect that can communicate with the outside world.
        /// - Returns: An effect that can communicate with the outside world and feed actions back into
        ///   the system.
        @inlinable public func reduce(into state: inout R0.State, action: R0.Action) -> ComposableArchitecture.Effect<R0.Action>
    }

    public struct _SequenceMany<Element> : ComposableArchitecture.Reducer where Element : ComposableArchitecture.Reducer {

        /// Evolves the current state of the reducer to the next state.
        ///
        /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
        /// features. To define a reducer by combining the logic of other reducers together, implement the
        /// ``body-swift.property`` requirement instead.
        ///
        /// - Parameters:
        ///   - state: The current state of the reducer.
        ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
        ///     side effect that can communicate with the outside world.
        /// - Returns: An effect that can communicate with the outside world and feed actions back into
        ///   the system.
        @inlinable public func reduce(into state: inout Element.State, action: Element.Action) -> ComposableArchitecture.Effect<Element.Action>
    }
}

/// Marks the case of an enum reducer as holding onto "ephemeral" state.
///
/// Apply this reducer to any cases of an enum reducer that holds onto state conforming to the
/// ``ComposableArchitecture/_EphemeralState`` protocol, such as `AlertState` and
/// `ConfirmationDialogState`:
///
/// ```swift
/// @Reducer
/// enum Destination {
///   @ReducerCaseEphemeral
///   case alert(AlertState<Alert>)
///   // ...
///
///   enum Alert {
///     case saveButtonTapped
///     case discardButtonTapped
///   }
/// }
/// ```
@attached(peer, names: named(`_`)) public macro ReducerCaseEphemeral() = #externalMacro(module: "ComposableArchitectureMacros", type: "ReducerCaseEphemeralMacro")

/// Marks the case of an enum reducer as "ignored", and as such will not compose the case's domain
/// into the rest of the reducer besides state.
///
/// Apply this macro to cases that do not hold onto reducer features, and instead hold onto plain
/// data that needs to be passed to a child view.
///
/// ```swift
/// @Reducer
/// enum Destination {
///   @ReducerCaseIgnored
///   case meeting(id: Meeting.ID)
///   // ...
/// }
/// ```
@attached(peer, names: named(`_`)) public macro ReducerCaseIgnored() = #externalMacro(module: "ComposableArchitectureMacros", type: "ReducerCaseIgnoredMacro")

/// A convenience for constraining a ``Reducer`` conformance.
///
/// This allows you to specify the `body` of a ``Reducer`` conformance like so:
///
/// ```swift
/// var body: some ReducerOf<Self> {
///   // ...
/// }
/// ```
///
/// â€¦instead of the more verbose:
///
/// ```swift
/// var body: some Reducer<State, Action> {
///   // ...
/// }
/// ```
public typealias ReducerOf<R> = ComposableArchitecture.Reducer<R.State, R.Action> where R : ComposableArchitecture.Reducer

/// Embeds a child reducer in a parent domain.
///
/// ``Scope`` allows you to transform a parent domain into a child domain, and then run a child
/// reduce on that subset domain. This is an important tool for breaking down large features into
/// smaller units and then piecing them together. The smaller units can be easier to understand and
/// test, and can even be packaged into their own isolated modules.
///
/// You hand ``Scope`` 3 pieces of data for it to do its job:
///
/// * A writable key path that identifies the child state inside the parent state.
/// * A case path that identifies the child actions inside the parent actions.
/// * A @``ReducerBuilder`` closure that describes the reducer you want to run on the child domain.
///
/// When run, it will intercept all child actions sent and feed them to the child reducer so that
/// it can update the parent state and execute effects.
///
/// For example, given the basic scaffolding of child reducer:
///
/// ```swift
/// @Reducer
/// struct Child {
///   struct State {
///     // ...
///   }
///   enum Action {
///     // ...
///   }
///   // ...
/// }
/// ```
///
/// A parent reducer with a domain that holds onto the child domain can use
/// ``init(state:action:child:)-88vdx`` to embed the child reducer in its
/// ``Reducer/body-swift.property``:
///
/// ```swift
/// @Reducer
/// struct Parent {
///   struct State {
///     var child: Child.State
///     // ...
///   }
///
///   enum Action {
///     case child(Child.Action)
///     // ...
///   }
///
///   var body: some Reducer<State, Action> {
///     Scope(state: \.child, action: \.child) {
///       Child()
///     }
///     Reduce { state, action in
///       // Additional parent logic and behavior
///     }
///   }
/// }
/// ```
///
/// ## Enum state
///
/// The ``Scope`` reducer also works when state is modeled as an enum, not just a struct. In that
/// case you can use ``init(state:action:child:fileID:filePath:line:column:)-9g44g`` to specify a
/// case path that identifies the case of state you want to scope to.
///
/// For example, if your state was modeled as an enum for unloaded/loading/loaded, you could
/// scope to the loaded case to run a reduce on only that case:
///
/// ```swift
/// @Reducer
/// struct Feature {
///   enum State {
///     case unloaded
///     case loading
///     case loaded(Child.State)
///   }
///   enum Action {
///     case child(Child.Action)
///     // ...
///   }
///
///   var body: some Reducer<State, Action> {
///     Scope(state: \.loaded, action: \.child) {
///       Child()
///     }
///     Reduce { state, action in
///       // Additional feature logic and behavior
///     }
///   }
/// }
/// ```
///
/// It is important to note that the order of combine ``Scope`` and your additional feature logic
/// matters. It must be combined before the additional logic. In the other order it would be
/// possible for the feature to intercept a child action, switch the state to another case, and
/// then the scoped child reducer would not be able to react to that action. That can cause subtle
/// bugs, and so we show a runtime warning in that case, and cause test failures.
///
/// For an alternative to using ``Scope`` with state case paths that enforces the order, check out
/// the ``ifCaseLet(_:action:then:fileID:filePath:line:column:)-rdrb`` operator.
public struct Scope<ParentState, ParentAction, Child> : ComposableArchitecture.Reducer where Child : ComposableArchitecture.Reducer {

    /// Initializes a reducer that runs the given child reducer against a slice of parent state and
    /// actions.
    ///
    /// Useful for combining child reducers into a parent.
    ///
    /// ```swift
    /// var body: some Reducer<State, Action> {
    ///   Scope(state: \.profile, action: \.profile) {
    ///     Profile()
    ///   }
    ///   Scope(state: \.settings, action: \.settings) {
    ///     Settings()
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - toChildState: A writable key path from parent state to a property containing child state.
    ///   - toChildAction: A case path from parent action to a case containing child actions.
    ///   - child: A reducer that will be invoked with child actions against child state.
    @inlinable public init<ChildState, ChildAction>(state toChildState: WritableKeyPath<ParentState, ChildState>, action toChildAction: CasePathsCore.CaseKeyPath<ParentAction, ChildAction>, @ComposableArchitecture.ReducerBuilder<ChildState, ChildAction> child: () -> Child) where ChildState == Child.State, ChildAction == Child.Action

    /// Initializes a reducer that runs the given child reducer against a slice of parent state and
    /// actions.
    ///
    /// Useful for combining reducers of mutually-exclusive enum state.
    ///
    /// ```swift
    /// var body: some Reducer<State, Action> {
    ///   Scope(state: \.loggedIn, action: \.loggedIn) {
    ///     LoggedIn()
    ///   }
    ///   Scope(state: \.loggedOut, action: \.loggedOut) {
    ///     LoggedOut()
    ///   }
    /// }
    /// ```
    ///
    /// > Warning: Be careful when assembling reducers that are scoped to cases of enum state. If a
    /// > scoped reducer receives a child action when its state is set to an unrelated case, it will
    /// > not be able to process the action, which is considered an application logic error and will
    /// > emit runtime warnings.
    /// >
    /// > This can happen if another reducer in the parent domain changes the child state to an
    /// > unrelated case when it handles the action _before_ the scoped reducer runs. For example, a
    /// > parent may receive a dismissal action from the child domain:
    /// >
    /// > ```swift
    /// > Reduce { state, action in
    /// >   switch action {
    /// >   case .loggedIn(.quitButtonTapped):
    /// >     state = .loggedOut(LoggedOut.State())
    /// >   // ...
    /// >   }
    /// > }
    /// > Scope(state: \.loggedIn, action: \.loggedIn) {
    /// >   LoggedIn()  // âš ï¸ Logged-in domain can't handle `quitButtonTapped`
    /// > }
    /// > ```
    /// >
    /// > If the parent domain contains additional logic for switching between cases of child state,
    /// > prefer ``Reducer/ifCaseLet(_:action:then:fileID:filePath:line:column:)-7sg8d``, which better ensures that
    /// > child logic runs _before_ any parent logic can replace child state:
    /// >
    /// > ```swift
    /// > Reduce { state, action in
    /// >   switch action {
    /// >   case .loggedIn(.quitButtonTapped):
    /// >     state = .loggedOut(LoggedOut.State())
    /// >   // ...
    /// >   }
    /// > }
    /// > .ifCaseLet(\.loggedIn, action: \.loggedIn) {
    /// >   LoggedIn()  // âœ… Receives actions before its case can change
    /// > }
    /// > ```
    ///
    /// - Parameters:
    ///   - toChildState: A case path from parent state to a case containing child state.
    ///   - toChildAction: A case path from parent action to a case containing child actions.
    ///   - child: A reducer that will be invoked with child actions against child state.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @inlinable public init<ChildState, ChildAction>(state toChildState: CasePathsCore.CaseKeyPath<ParentState, ChildState>, action toChildAction: CasePathsCore.CaseKeyPath<ParentAction, ChildAction>, @ComposableArchitecture.ReducerBuilder<ChildState, ChildAction> child: () -> Child, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) where ChildState == Child.State, ChildAction == Child.Action

    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @inlinable public init<ChildState, ChildAction>(state toChildState: WritableKeyPath<ParentState, ChildState>, action toChildAction: CasePathsCore.AnyCasePath<ParentAction, ChildAction>, @ComposableArchitecture.ReducerBuilder<ChildState, ChildAction> child: () -> Child) where ChildState == Child.State, ChildAction == Child.Action

    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @inlinable public init<ChildState, ChildAction>(state toChildState: CasePathsCore.AnyCasePath<ParentState, ChildState>, action toChildAction: CasePathsCore.AnyCasePath<ParentAction, ChildAction>, @ComposableArchitecture.ReducerBuilder<ChildState, ChildAction> child: () -> Child, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) where ChildState == Child.State, ChildAction == Child.Action

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout ParentState, action: ParentAction) -> ComposableArchitecture.Effect<ParentAction>
}

public struct ScopeID<State, Action> : Hashable {
}

/// A type that can send actions back into the system when used from
/// ``Effect/run(priority:operation:catch:fileID:filePath:line:column:)``.
///
/// This type implements [`callAsFunction`][callAsFunction] so that you invoke it as a function
/// rather than calling methods on it:
///
/// ```swift
/// return .run { send in
///   await send(.started)
///   for await event in self.events {
///     send(.event(event))
///   }
///   await send(.finished)
/// }
/// ```
///
/// You can also send actions with animation and transaction:
///
/// ```swift
/// await send(.started, animation: .spring())
/// await send(.finished, transaction: .init(animation: .default))
/// ```
///
/// See ``Effect/run(priority:operation:catch:fileID:filePath:line:column:)`` for more information on how to
/// use this value to construct effects that can emit any number of times in an asynchronous
/// context.
///
/// [callAsFunction]: https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID622
@MainActor public struct Send<Action> : Sendable {

    @MainActor public init(send: @escaping @MainActor @Sendable (Action) -> Void)

    /// Sends an action back into the system from an effect.
    ///
    /// - Parameter action: An action.
    @MainActor public func callAsFunction(_ action: Action)

    /// Sends an action back into the system from an effect with animation.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - animation: An animation.
    @MainActor public func callAsFunction(_ action: Action, animation: Animation?)

    /// Sends an action back into the system from an effect with transaction.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - transaction: A transaction.
    @MainActor public func callAsFunction(_ action: Action, transaction: Transaction)
}

/// A wrapper type for actions that can be presented in a navigation stack.
///
/// Use this type for modeling a feature's domain that needs to present child features using
/// ``Reducer/forEach(_:action:destination:fileID:filePath:line:column:)-9svqb``.
///
/// See the dedicated article on <doc:Navigation> for more information on the library's navigation
/// tools, and in particular see <doc:StackBasedNavigation> for information on modeling navigation
/// using ``StackAction`` for navigation stacks.
public enum StackAction<State, Action> : CasePathsCore.CasePathable {

    /// An action sent to the associated stack element at a given identifier.
    indirect case element(id: ComposableArchitecture.StackElementID, action: Action)

    /// An action sent to dismiss the associated stack element at a given identifier.
    case popFrom(id: ComposableArchitecture.StackElementID)

    /// An action sent to present the given state at a given identifier in a navigation stack. This
    /// action is typically sent from the view via the `NavigationLink(value:)` initializer.
    case push(id: ComposableArchitecture.StackElementID, state: State)

    /// A collection of all case paths of this type.
    public static var allCasePaths: ComposableArchitecture.StackAction<State, Action>.AllCasePaths { get }

    /// A type that can represent a collection of all case paths of this type.
    public struct AllCasePaths {

        public var element: CasePathsCore.AnyCasePath<ComposableArchitecture.StackAction<State, Action>, (id: ComposableArchitecture.StackElementID, action: Action)> { get }

        public var popFrom: CasePathsCore.AnyCasePath<ComposableArchitecture.StackAction<State, Action>, ComposableArchitecture.StackElementID> { get }

        public var push: CasePathsCore.AnyCasePath<ComposableArchitecture.StackAction<State, Action>, (id: ComposableArchitecture.StackElementID, state: State)> { get }

        public subscript(id id: ComposableArchitecture.StackElementID) -> CasePathsCore.AnyCasePath<ComposableArchitecture.StackAction<State, Action>, Action> { get }
    }
}

extension StackAction : Equatable where State : Equatable, Action : Equatable {
}

extension StackAction : Hashable where State : Hashable, Action : Hashable {
}

extension StackAction : Sendable where State : Sendable, Action : Sendable {
}

/// A convenience type alias for referring to a stack action of a given reducer's domain.
///
/// Instead of specifying two generics:
///
/// ```swift
///     case path(StackAction<Path.State, Path.Action>)
/// ```
///
/// You can specify a single generic:
///
/// ```swift
///     case path(StackActionOf<Path>)
/// ```
public typealias StackActionOf<R> = ComposableArchitecture.StackAction<R.State, R.Action> where R : ComposableArchitecture.Reducer

/// An opaque type that identifies an element of ``StackState``.
///
/// The ``StackState`` type creates instances of this identifier when new elements are added to
/// the stack. This makes it possible to easily look up specific elements in the stack without
/// resorting to positional indices, which can be error prone, especially when dealing with async
/// effects.
///
/// The identifier is backed by a deterministic, generational ID. This allows you to predict how
/// IDs will be created and allows you to write tests for how features behave in the stack.
///
/// ```swift
/// @Test
/// func basics() {
///   var path = StackState<Int>()
///   path.append(42)
///   XCTAssertEqual(path[id: 0], 42)
///   path.append(1729)
///   XCTAssertEqual(path[id: 1], 1729)
///
///   path.removeAll()
///   path.append(-1)
///   XCTAssertEqual(path[id: 2], -1)
/// }
/// ```
///
/// Notice that after removing all elements and appending a new element, the ID generated was 2 and
/// did not go back to 0. This is because in tests the IDs are _generational_, which means they
/// keep counting up, even if you remove elements from the stack.
public struct StackElementID : Hashable, Sendable {

    public var generation: Int

    public init(generation: Int)
}

extension StackElementID : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension StackElementID : CustomDump.CustomDumpStringConvertible {

    /// The custom dump description for this instance.
    public var customDumpDescription: String { get }
}

extension StackElementID : ExpressibleByIntegerLiteral {

    /// Creates an instance initialized to the specified integer value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using an integer literal. For example:
    ///
    ///     let x = 23
    ///
    /// In this example, the assignment to the `x` constant calls this integer
    /// literal initializer behind the scenes.
    ///
    /// - Parameter value: The value to create.
    public init(integerLiteral value: Int)
}

public struct StackElementIDGenerator : Dependencies.DependencyKey, Sendable {

    public let next: @Sendable () -> ComposableArchitecture.StackElementID

    public let peek: @Sendable () -> ComposableArchitecture.StackElementID

    public func callAsFunction() -> ComposableArchitecture.StackElementID

    /// The live value for the dependency key.
    ///
    /// This is the value used by default when running the application in a simulator or on a device.
    /// Using a live dependency in a test context will lead to a test failure as you should mock your
    /// dependencies for tests.
    ///
    /// To automatically supply a test dependency in a test context, consider implementing the
    /// ``testValue-535kh`` requirement.
    public static var liveValue: ComposableArchitecture.StackElementIDGenerator { get }

    /// The test value for the dependency key.
    ///
    /// This value is automatically used when the associated dependency value is accessed from an
    /// XCTest run, as well as when the current ``DependencyValues/context`` is set to
    /// ``DependencyContext/test``:
    ///
    /// ```swift
    /// withDependencies {
    ///   $0.context = .test
    /// } operation: {
    ///   // Dependencies accessed here default to their "test" value
    /// }
    /// ```
    public static var testValue: ComposableArchitecture.StackElementIDGenerator { get }
}

/// A list of data representing the content of a navigation stack.
///
/// Use this type for modeling a feature's domain that needs to present child features using
/// ``Reducer/forEach(_:action:destination:fileID:filePath:line:column:)-9svqb``.
///
/// See the dedicated article on <doc:Navigation> for more information on the library's navigation
/// tools, and in particular see <doc:StackBasedNavigation> for information on modeling navigation
/// using ``StackState`` for navigation stacks. Also see
/// <doc:StackBasedNavigation#StackState-vs-NavigationPath> to understand how ``StackState``
/// compares to SwiftUI's `NavigationPath` type.
public struct StackState<Element> {

    /// An ordered set of identifiers, one for each stack element.
    ///
    /// You can use this set to iterate over stack elements along with their associated identifiers.
    ///
    /// ```swift
    /// for (id, element) in zip(state.path.ids, state.path) {
    ///   if element.isDeleted {
    ///     state.path.pop(from: id)
    ///     break
    ///   }
    /// }
    /// ```
    public var ids: OrderedCollections.OrderedSet<ComposableArchitecture.StackElementID> { get }

    /// Accesses the value associated with the given id for reading and writing.
    public subscript(id id: ComposableArchitecture.StackElementID, fileID fileID: ComposableArchitecture._HashableStaticString = #fileID, filePath filePath: ComposableArchitecture._HashableStaticString = #filePath, line line: UInt = #line, column column: UInt = #column) -> Element?

    /// Accesses the value associated with the given id and case for reading and writing.
    ///
    /// When using stack-based navigation (see <doc:StackBasedNavigation>) you will typically have a
    /// single enum that represents all of the destinations that can be pushed onto the stack, and you
    /// will hold that state in ``StackState``:
    ///
    /// ```swift
    /// struct State {
    ///   var path = StackState<Path.State>()
    /// }
    /// ```
    ///
    /// You can use this subscript for a succinct syntax to modify the data in a particular case of
    /// the `Path.State` enum, like so:
    ///
    /// ```swift
    /// state.path[id: 0, case: \.edit]?.alert = AlertState {
    ///   Text("Delete?")
    /// }
    /// ```
    ///
    /// > Important: Accessing the wrong case will result in a runtime warning and test failure.
    public subscript<Case>(id id: ComposableArchitecture.StackElementID, case path: CasePathsCore.CaseKeyPath<Element, Case>) -> Case? where Element : CasePathsCore.CasePathable

    @available(iOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this subscript with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    public subscript<Case>(id id: ComposableArchitecture.StackElementID, case path: CasePathsCore.AnyCasePath<Element, Case>, fileID fileID: ComposableArchitecture._HashableStaticString = #fileID, filePath filePath: ComposableArchitecture._HashableStaticString = #filePath, line line: UInt = #line, column column: UInt = #column) -> Case?

    /// Pops the element corresponding to `id` from the stack, and all elements after it.
    ///
    /// - Parameter id: The identifier of an element in the stack.
    public mutating func pop(from id: ComposableArchitecture.StackElementID)

    /// Pops all elements that come after the element corresponding to `id` in the stack.
    ///
    /// - Parameter id: The identifier of an element in the stack.
    public mutating func pop(to id: ComposableArchitecture.StackElementID)
}

extension StackState {

    public struct Component : Hashable {

        public let id: ComposableArchitecture.StackElementID

        public var element: Element

        public init(id: ComposableArchitecture.StackElementID, element: Element)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: ComposableArchitecture.StackState<Element>.Component, rhs: ComposableArchitecture.StackState<Element>.Component) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)
    }

    public struct PathView : MutableCollection, RandomAccessCollection, RangeReplaceableCollection {

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: Int { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: Int { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: Int) -> Int

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: Int) -> Int

        /// Accesses the element at the specified position.
        ///
        /// For example, you can replace an element of an array by using its
        /// subscript.
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     streets[1] = "Butler"
        ///     print(streets[1])
        ///     // Prints "Butler"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one
        /// past the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: Int) -> ComposableArchitecture.StackState<Element>.Component

        /// Creates a new, empty collection.
        public init()

        /// Replaces the specified subrange of elements with the given collection.
        ///
        /// This method has the effect of removing the specified range of elements
        /// from the collection and inserting the new elements at the same location.
        /// The number of new elements need not match the number of elements being
        /// removed.
        ///
        /// In this example, three elements in the middle of an array of integers are
        /// replaced by the five elements of a `Repeated<Int>` instance.
        ///
        ///      var nums = [10, 20, 30, 40, 50]
        ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
        ///      print(nums)
        ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
        ///
        /// If you pass a zero-length range as the `subrange` parameter, this method
        /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
        /// the `insert(contentsOf:at:)` method instead is preferred.
        ///
        /// Likewise, if you pass a zero-length collection as the `newElements`
        /// parameter, this method removes the elements in the given subrange
        /// without replacement. Calling the `removeSubrange(_:)` method instead is
        /// preferred.
        ///
        /// Calling this method may invalidate any existing indices for use with this
        /// collection.
        ///
        /// - Parameters:
        ///   - subrange: The subrange of the collection to replace. The bounds of
        ///     the range must be valid indices of the collection.
        ///   - newElements: The new elements to add to the collection.
        ///
        /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
        ///   *m* is the length of `newElements`. If the call to this method simply
        ///   appends the contents of `newElements` to the collection, this method is
        ///   equivalent to `append(contentsOf:)`.
        public mutating func replaceSubrange(_ subrange: Range<Int>, with newElements: some Collection<ComposableArchitecture.StackState<Element>.Component>)
    }
}

extension StackState : RandomAccessCollection, RangeReplaceableCollection {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: Int) -> Int

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: Int) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> Element { get }

    /// Creates a new, empty collection.
    public init()

    /// Removes all elements from the collection.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameter keepCapacity: Pass `true` to request that the collection
    ///   avoid releasing its storage. Retaining the collection's storage can
    ///   be a useful optimization when you're planning to grow the collection
    ///   again. The default value is `false`.
    ///
    /// - Complexity: O(*n*), where *n* is the length of the collection.
    public mutating func removeAll(keepingCapacity keepCapacity: Bool = false)

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange(_ subrange: Range<Int>, with newElements: some Collection<Element>)
}

extension StackState : Equatable where Element : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.StackState<Element>, rhs: ComposableArchitecture.StackState<Element>) -> Bool
}

extension StackState : Hashable where Element : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

extension StackState : Sendable where Element : Sendable {
}

extension StackState : Decodable where Element : Decodable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

extension StackState : Encodable where Element : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

extension StackState : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension StackState : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension StackState : CustomDump.CustomDumpReflectable {

    /// The custom dump mirror for this instance.
    public var customDumpMirror: Mirror { get }
}

/// A store represents the runtime that powers the application. It is the object that you will pass
/// around to views that need to interact with the application.
///
/// You will typically construct a single one of these at the root of your application:
///
/// ```swift
/// @main
/// struct MyApp: App {
///   var body: some Scene {
///     WindowGroup {
///       RootView(
///         store: Store(initialState: AppFeature.State()) {
///           AppFeature()
///         }
///       )
///     }
///   }
/// }
/// ```
///
/// â€¦and then use the ``scope(state:action:)-90255`` method to derive more focused stores that can be
/// passed to subviews.
///
/// ### Scoping
///
/// The most important operation defined on ``Store`` is the ``scope(state:action:)-90255`` method,
/// which allows you to transform a store into one that deals with child state and actions. This is
/// necessary for passing stores to subviews that only care about a small portion of the entire
/// application's domain.
///
/// For example, if an application has a tab view at its root with tabs for activity, search, and
/// profile, then we can model the domain like this:
///
/// ```swift
/// @Reducer
/// struct AppFeature {
///   struct State {
///     var activity: Activity.State
///     var profile: Profile.State
///     var search: Search.State
///   }
///
///   enum Action {
///     case activity(Activity.Action)
///     case profile(Profile.Action)
///     case search(Search.Action)
///   }
///
///   // ...
/// }
/// ```
///
/// We can construct a view for each of these domains by applying ``scope(state:action:)-90255`` to
/// a store that holds onto the full app domain in order to transform it into a store for each
/// subdomain:
///
/// ```swift
/// struct AppView: View {
///   let store: StoreOf<AppFeature>
///
///   var body: some View {
///     TabView {
///       ActivityView(
///         store: store.scope(state: \.activity, action: \.activity)
///       )
///       .tabItem { Text("Activity") }
///
///       SearchView(
///         store: store.scope(state: \.search, action: \.search)
///       )
///       .tabItem { Text("Search") }
///
///       ProfileView(
///         store: store.scope(state: \.profile, action: \.profile)
///       )
///       .tabItem { Text("Profile") }
///     }
///   }
/// }
/// ```
///
/// ### ObservableObject conformance
///
/// The store conforms to `ObservableObject` but is _not_ observable via the `@ObservedObject`
/// property wrapper. This conformance is completely inert and its sole purpose is to allow stores
/// to be held in SwiftUI's `@StateObject` property wrapper.
///
/// Instead, stores should be observed through Swift's Observation framework (or the Perception
/// package when targeting iOS <17) by applying the ``ObservableState()`` macro to your feature's
/// state.
@MainActor @dynamicMemberLookup @preconcurrency final public class Store<State, Action> {

    @MainActor public var effectCancellables: [UUID : AnyCancellable] { get }

    /// Initializes a store from an initial state and a reducer.
    ///
    /// - Parameters:
    ///   - initialState: The state to start the application in.
    ///   - reducer: The reducer that powers the business logic of the application.
    ///   - prepareDependencies: A closure that can be used to override dependencies that will be accessed
    ///     by the reducer.
    @MainActor public convenience init<R>(initialState: @autoclosure () -> R.State, @ComposableArchitecture.ReducerBuilder<State, Action> reducer: () -> R, withDependencies prepareDependencies: ((inout Dependencies.DependencyValues) -> Void)? = nil) where State == R.State, Action == R.Action, R : ComposableArchitecture.Reducer

    deinit

    /// Calls the given closure with a snapshot of the current state of the store.
    ///
    /// A lightweight way of accessing store state when state is not observable and ``state-1qxwl`` is
    /// unavailable.
    ///
    /// - Parameter body: A closure that takes the current state of the store as its sole argument. If
    ///   the closure has a return value, that value is also used as the return value of the
    ///   `withState` method. The state argument reflects the current state of the store only for the
    ///   duration of the closure's execution, and is only observable over time, _e.g._ by SwiftUI, if
    ///   it conforms to ``ObservableState``.
    /// - Returns: The return value, if any, of the `body` closure.
    @MainActor public func withState<R>(_ body: (_ state: State) -> R) -> R

    /// Sends an action to the store.
    ///
    /// This method returns a ``StoreTask``, which represents the lifecycle of the effect started from
    /// sending an action. You can use this value to tie the effect's lifecycle _and_ cancellation to
    /// an asynchronous context, such as SwiftUI's `task` view modifier:
    ///
    /// ```swift
    /// .task { await store.send(.task).finish() }
    /// ```
    ///
    /// - Parameter action: An action.
    /// - Returns: A ``StoreTask`` that represents the lifecycle of the effect executed when
    ///   sending the action.
    @discardableResult
    @MainActor public func send(_ action: Action) -> ComposableArchitecture.StoreTask

    /// Sends an action to the store with a given animation.
    ///
    /// See ``Store/send(_:)`` for more info.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - animation: An animation.
    @discardableResult
    @MainActor public func send(_ action: Action, animation: Animation?) -> ComposableArchitecture.StoreTask

    /// Sends an action to the store with a given transaction.
    ///
    /// See ``Store/send(_:)`` for more info.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - transaction: A transaction.
    @discardableResult
    @MainActor public func send(_ action: Action, transaction: Transaction) -> ComposableArchitecture.StoreTask

    /// Scopes the store to one that exposes child state and actions.
    ///
    /// This can be useful for deriving new stores to hand to child views in an application. For
    /// example:
    ///
    /// ```swift
    /// @Reducer
    /// struct AppFeature {
    ///   @ObservableState
    ///   struct State {
    ///     var login: Login.State
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case login(Login.Action)
    ///     // ...
    ///   }
    ///   // ...
    /// }
    ///
    /// // A store that runs the entire application.
    /// let store = Store(initialState: AppFeature.State()) {
    ///   AppFeature()
    /// }
    ///
    /// // Construct a login view by scoping the store
    /// // to one that works with only login domain.
    /// LoginView(
    ///   store: store.scope(state: \.login, action: \.login)
    /// )
    /// ```
    ///
    /// Scoping in this fashion allows you to better modularize your application. In this case,
    /// `LoginView` could be extracted to a module that has no access to `AppFeature.State` or
    /// `AppFeature.Action`.
    ///
    /// - Parameters:
    ///   - state: A key path from `State` to `ChildState`.
    ///   - action: A case key path from `Action` to `ChildAction`.
    /// - Returns: A new store with its domain (state and action) transformed.
    @MainActor public func scope<ChildState, ChildAction>(state: KeyPath<State, ChildState>, action: CasePathsCore.CaseKeyPath<Action, ChildAction>) -> ComposableArchitecture.Store<ChildState, ChildAction>

    @available(*, deprecated, message: "Pass 'state' a key path to child state and 'action' a case key path to child action, instead. For more information see the following migration guide: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Store-scoping-with-key-paths")
    @MainActor public func scope<ChildState, ChildAction>(state toChildState: @escaping (_ state: State) -> ChildState, action fromChildAction: @escaping (_ childAction: ChildAction) -> Action) -> ComposableArchitecture.Store<ChildState, ChildAction>

    @MainActor public var currentState: State { get }

    @MainActor public func send(_ action: Action) -> Task<Void, Never>?

    /// A publisher that emits when state changes.
    ///
    /// This publisher supports dynamic member lookup so that you can pluck out a specific field in
    /// the state:
    ///
    /// ```swift
    /// store.publisher.alert
    ///   .sink { ... }
    /// ```
    @MainActor public var publisher: ComposableArchitecture.StorePublisher<State> { get }

    @MainActor public func id<ChildState, ChildAction>(state: KeyPath<State, ChildState>, action: CasePathsCore.CaseKeyPath<Action, ChildAction>) -> ComposableArchitecture.ScopeID<State, Action>
}

extension Store where State : ComposableArchitecture.CaseReducerState, Action == State.StateReducer.Action {

    /// A destructurable view of a store on a collection of cases.
    @MainActor public var `case`: State.StateReducer.CaseScope { get }
}

extension Store where State : ComposableArchitecture.ObservableState, State == Action.State, Action : ComposableArchitecture.BindableAction {

    @MainActor public subscript<Value>(dynamicMember keyPath: WritableKeyPath<State, Value>) -> Value where Value : Equatable, Value : Sendable
}

extension Store where State : ComposableArchitecture.ObservableState, State : Equatable, State : Sendable, State == Action.State, Action : ComposableArchitecture.BindableAction {

    @MainActor public var state: State
}

extension Store where State : ComposableArchitecture.ObservableState, State == Action.ViewAction.State, Action : ComposableArchitecture.ViewAction, Action.ViewAction : ComposableArchitecture.BindableAction {

    @MainActor public subscript<Value>(dynamicMember keyPath: WritableKeyPath<State, Value>) -> Value where Value : Equatable, Value : Sendable
}

extension Store where State : ComposableArchitecture.ObservableState, State : Equatable, State : Sendable, State == Action.ViewAction.State, Action : ComposableArchitecture.ViewAction, Action.ViewAction : ComposableArchitecture.BindableAction {

    @MainActor public var state: State
}

extension Store where State : ComposableArchitecture.ObservableState {

    /// Scopes the store of an identified collection to a collection of stores.
    ///
    /// This operator is most often used with SwiftUI's `ForEach` view. For example, suppose you
    /// have a feature that contains an `IdentifiedArray` of child features like so:
    ///
    /// ```swift
    /// @Reducer
    /// struct Feature {
    ///   @ObservableState
    ///   struct State {
    ///     var rows: IdentifiedArrayOf<Child.State> = []
    ///   }
    ///   enum Action {
    ///     case rows(IdentifiedActionOf<Child>)
    ///   }
    ///   var body: some ReducerOf<Self> {
    ///     Reduce { state, action in
    ///       // Core feature logic
    ///     }
    ///     .forEach(\.rows, action: \.rows) {
    ///       Child()
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Then in the view you can use this operator, with `ForEach`, to derive a store for
    /// each element in the identified collection:
    ///
    /// ```swift
    /// struct FeatureView: View {
    ///   let store: StoreOf<Feature>
    ///
    ///   var body: some View {
    ///     List {
    ///       ForEach(store.scope(state: \.rows, action: \.rows), id: \.state.id) { store in
    ///         ChildView(store: store)
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// > Tip: If you do not depend on the identity of the state of each row (_e.g._, the state's
    /// > `id` is not associated with a selection binding), you can omit the `id` parameter, as the
    /// > `Store` type is identifiable by its object identity:
    /// >
    /// > ```diff
    /// >  ForEach(
    /// > -  store.scope(state: \.rows, action: \.rows),
    /// > -  id: \.state.id,
    /// > +  store.scope(state: \.rows, action: \.rows)
    /// >  ) { childStore in
    /// >    ChildView(store: childStore)
    /// >  }
    /// > ```
    ///
    /// - Parameters:
    ///   - state: A key path to an identified array of child state.
    ///   - action: A case key path to an identified child action.
    ///   - column: The column.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    /// - Returns: An collection of stores of child state.
    @MainActor public func scope<ElementID, ElementState, ElementAction>(state: KeyPath<State, IdentifiedCollections.IdentifiedArray<ElementID, ElementState>>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.IdentifiedAction<ElementID, ElementAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> some RandomAccessCollection<ComposableArchitecture.Store<ElementState, ElementAction>> where ElementID : Hashable, ElementID : Sendable

}

extension Store {

    @MainActor public func scope<ChildState, ChildAction>(component: ComposableArchitecture.StackState<ChildState>.Component, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> ComposableArchitecture.Store<ChildState, ChildAction> where State == ComposableArchitecture.StackState<ChildState>, Action == ComposableArchitecture.StackAction<ChildState, ChildAction>
}

extension Store {

    @MainActor public subscript<ElementState, ElementAction>(fileID fileID: ComposableArchitecture._HashableStaticString, filePath filePath: ComposableArchitecture._HashableStaticString, line line: UInt, column column: UInt) -> ComposableArchitecture.StackState<ElementState>.PathView where State == ComposableArchitecture.StackState<ElementState>, Action == ComposableArchitecture.StackAction<ElementState, ElementAction>
}

extension Store : PerceptionCore.Perceptible {
}

extension Store where State : ComposableArchitecture.ObservableState {

    /// Direct access to state in the store when `State` conforms to ``ObservableState``.
    @MainActor public var state: State { get }

    @MainActor public subscript<Value>(dynamicMember keyPath: KeyPath<State, Value>) -> Value { get }
}

extension Store : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    nonisolated public static func == (lhs: ComposableArchitecture.Store<State, Action>, rhs: ComposableArchitecture.Store<State, Action>) -> Bool
}

extension Store : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    nonisolated public func hash(into hasher: inout Hasher)
}

extension Store : Identifiable {
}

extension Store where State : ComposableArchitecture.ObservableState {

    /// Scopes the store to optional child state and actions.
    ///
    /// If your feature holds onto a child feature as an optional:
    ///
    /// ```swift
    /// @Reducer
    /// struct Feature {
    ///   @ObservableState
    ///   struct State {
    ///     var child: Child.State?
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case child(Child.Action)
    ///     // ...
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// â€¦then you can use this `scope` operator in order to transform a store of your feature into
    /// a non-optional store of the child domain:
    ///
    /// ```swift
    /// if let childStore = store.scope(state: \.child, action: \.child) {
    ///   ChildView(store: childStore)
    /// }
    /// ```
    ///
    /// > Important: This operation should only be used from within a SwiftUI view or within
    /// > `withPerceptionTracking` in order for changes of the optional state to be properly
    /// > observed.
    ///
    /// - Parameters:
    ///   - stateKeyPath: A key path to optional child state.
    ///   - actionKeyPath: A case key path to child actions.
    ///   - fileID: The source `#fileID` associated with the scoping.
    ///   - filePath: The source `#filePath` associated with the scoping.
    ///   - line: The source `#line` associated with the scoping.
    ///   - column: The source `#column` associated with the scoping.
    /// - Returns: An optional store of non-optional child state and actions.
    @MainActor public func scope<ChildState, ChildAction>(state stateKeyPath: KeyPath<State, ChildState?>, action actionKeyPath: CasePathsCore.CaseKeyPath<Action, ChildAction>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> ComposableArchitecture.Store<ChildState, ChildAction>?
}

extension Store where State : ComposableArchitecture.ObservableState {

    @MainActor public subscript<ChildState, ChildAction>(id id: AnyHashable?, state state: KeyPath<State, ChildState?>, action action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.PresentationAction<ChildAction>>, isInViewBody isInViewBody: Bool, fileID fileID: ComposableArchitecture._HashableStaticString, filePath filePath: ComposableArchitecture._HashableStaticString, line line: UInt, column column: UInt) -> ComposableArchitecture.Store<ChildState, ChildAction>?
}

extension Store : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    nonisolated public var debugDescription: String { get }
}

extension Store : ObservableObject {
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
extension Store : Observable {
}

extension Store {

    /// Calls one of two closures depending on whether a store's optional state is `nil` or not, and
    /// whenever this condition changes for as long as the cancellable lives.
    ///
    /// If the store's state is non-`nil`, it will safely unwrap the value and bundle it into a new
    /// store of non-optional state that is passed to the first closure. If the store's state is
    /// `nil`, the second closure is called instead.
    ///
    /// This method is useful for handling navigation in UIKit. The state for a screen the user wants
    /// to navigate to can be held as an optional value in the parent, and when that value goes from
    /// `nil` to non-`nil`, or non-`nil` to `nil`, you can update the navigation stack accordingly:
    ///
    /// ```swift
    /// class ParentViewController: UIViewController {
    ///   let store: Store<ParentState, ParentAction>
    ///   var cancellables: Set<AnyCancellable> = []
    ///   // ...
    ///   func viewDidLoad() {
    ///     // ...
    ///     store
    ///       .scope(state: \.optionalChild, action: \.child)
    ///       .ifLet(
    ///         then: { [weak self] childStore in
    ///           self?.navigationController?.pushViewController(
    ///             ChildViewController(store: childStore),
    ///             animated: true
    ///           )
    ///         },
    ///         else: { [weak self] in
    ///           guard let self else { return }
    ///           navigationController?.popToViewController(self, animated: true)
    ///         }
    ///       )
    ///       .store(in: &cancellables)
    ///   }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - unwrap: A function that is called with a store of non-optional state when the store's
    ///     state is non-`nil`, or whenever it goes from `nil` to non-`nil`.
    ///   - else: A function that is called when the store's optional state is `nil`, or whenever it
    ///     goes from non-`nil` to `nil`.
    /// - Returns: A cancellable that maintains a subscription to updates whenever the store's state
    ///   goes from `nil` to non-`nil` and vice versa, so that the caller can react to these changes.
    @available(iOS, deprecated: 9999, message: "Use 'observe' and 'if let store.scope', instead.")
    @available(macOS, deprecated: 9999, message: "Use 'observe' and 'if let store.scope', instead.")
    @available(tvOS, deprecated: 9999, message: "Use 'observe' and 'if let store.scope', instead.")
    @available(watchOS, deprecated: 9999, message: "Use 'observe' and 'if let store.scope', instead.")
    @MainActor public func ifLet<Wrapped>(then unwrap: @escaping (_ store: ComposableArchitecture.Store<Wrapped, Action>) -> Void, else: @escaping () -> Void = {}) -> any Cancellable where State == Wrapped?
}

/// A convenience type alias for referring to a store of a given reducer's domain.
///
/// Instead of specifying two generics:
///
/// ```swift
/// let store: Store<Feature.State, Feature.Action>
/// ```
///
/// You can specify a single generic:
///
/// ```swift
/// let store: StoreOf<Feature>
/// ```
public typealias StoreOf<R> = ComposableArchitecture.Store<R.State, R.Action> where R : ComposableArchitecture.Reducer

/// A publisher of store state.
@dynamicMemberLookup public struct StorePublisher<State> : Publisher {

    /// The kind of values published by this publisher.
    public typealias Output = State

    /// The kind of errors this publisher might publish.
    ///
    /// Use `Never` if this `Publisher` does not publish errors.
    public typealias Failure = Never

    /// Attaches the specified subscriber to this publisher.
    ///
    /// Implementations of ``Publisher`` must implement this method.
    ///
    /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
    ///
    /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
    public func receive(subscriber: some Subscriber<State, Never>)

    /// Returns the resulting publisher of a given key path.
    public subscript<Value>(dynamicMember keyPath: KeyPath<State, Value>) -> ComposableArchitecture.StorePublisher<Value> where Value : Equatable { get }
}

/// The type returned from ``Store/send(_:)`` that represents the lifecycle of the effect
/// started from sending an action.
///
/// You can use this value to tie the effect's lifecycle _and_ cancellation to an asynchronous
/// context, such as the `task` view modifier.
///
/// ```swift
/// .task { await store.send(.task).finish() }
/// ```
///
/// > Note: Unlike Swift's `Task` type, ``StoreTask`` automatically sets up a cancellation
/// > handler between the current async context and the task.
///
/// See ``TestStoreTask`` for the analog returned from ``TestStore``.
public struct StoreTask : Hashable, Sendable {

    /// Cancels the underlying task.
    public func cancel()

    /// Waits for the task to finish.
    public func finish() async

    /// A Boolean value that indicates whether the task should stop executing.
    ///
    /// After the value of this property becomes `true`, it remains `true` indefinitely. There is no
    /// way to uncancel a task.
    public var isCancelled: Bool { get }
}

/// A view that observes when enum state held in a store changes cases, and provides stores to
/// ``CaseLet`` views.
///
/// An application may model parts of its state with enums. For example, app state may differ if a
/// user is logged-in or not:
///
/// ```swift
/// @Reducer
/// struct AppFeature {
///   enum State {
///     case loggedIn(LoggedInState)
///     case loggedOut(LoggedOutState)
///   }
///   // ...
/// }
/// ```
///
/// In the view layer, a store on this state can switch over each case using a ``SwitchStore`` and
/// a ``CaseLet`` view per case:
///
/// ```swift
/// struct AppView: View {
///   let store: StoreOf<AppFeature>
///
///   var body: some View {
///     SwitchStore(self.store) { state in
///       switch state {
///       case .loggedIn:
///         CaseLet(
///           /AppFeature.State.loggedIn, action: AppFeature.Action.loggedIn
///         ) { loggedInStore in
///           LoggedInView(store: loggedInStore)
///         }
///       case .loggedOut:
///         CaseLet(
///           /AppFeature.State.loggedOut, action: AppFeature.Action.loggedOut
///         ) { loggedOutStore in
///           LoggedOutView(store: loggedOutStore)
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// > Important: The `SwitchStore` view builder is only evaluated when the case of state passed to
/// > it changes. As such, you should not rely on this value for anything other than checking the
/// > current case, _e.g._ by switching on it and routing to an appropriate `CaseLet`.
///
/// See ``Reducer/ifCaseLet(_:action:then:fileID:filePath:line:column:)-7sg8d`` and
/// ``Scope/init(state:action:child:fileID:filePath:line:column:)-9g44g`` for embedding reducers
/// that operate on each case of an enum in reducers that operate on the entire enum.
@available(iOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@available(macOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@available(tvOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@available(watchOS, deprecated: 9999, message: "Use 'switch' with a store of observable state, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-SwitchStore-and-CaseLet-with-switch-and-case]")
@MainActor public struct SwitchStore<State, Action, Content> : View where Content : View {

    @MainActor public let store: ComposableArchitecture.Store<State, Action>

    @MainActor public let content: (State) -> Content

    @MainActor public init(_ store: ComposableArchitecture.Store<State, Action>, @ViewBuilder content: @escaping (_ initialState: State) -> Content)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

/// A value that represents either a success or a failure. This type differs from Swift's `Result`
/// type in that it uses only one generic for the success case, leaving the failure case as an
/// untyped `Error`.
///
/// This type is needed because Swift's concurrency tools can only express untyped errors, such as
/// `async` functions and `AsyncSequence`, and so their output can realistically only be bridged to
/// `Result<_, any Error>`. However, `Result<_, any Error>` is never `Equatable` since `Error` is not
/// `Equatable`, and equatability is very important for testing in the Composable Architecture. By
/// defining our own type we get the ability to recover equatability in most situations.
///
/// If someday Swift gets typed `throws`, then we can eliminate this type and rely solely on
/// `Result`.
///
/// You typically use this type as the payload of an action which receives a response from an
/// effect:
///
/// ```swift
/// enum Action: Equatable {
///   case factButtonTapped
///   case factResponse(TaskResult<String>)
/// }
/// ```
///
/// Then you can model your dependency as using simple `async` and `throws` functionality:
///
/// ```swift
/// struct NumberFactClient {
///   var fetch: (Int) async throws -> String
/// }
/// ```
///
/// And finally you can use ``Effect/run(priority:operation:catch:fileID:filePath:line:column:)`` to construct an
/// effect in the reducer that invokes the `numberFact` endpoint and wraps its response in a
/// ``TaskResult`` by using its catching initializer, ``TaskResult/init(catching:)``:
///
/// ```swift
/// case .factButtonTapped:
///   return .run { send in
///     await send(
///       .factResponse(
///         await Result { try await self.numberFact.fetch(state.number) }
///       )
///     )
///   }
///
/// case let .factResponse(.success(fact)):
///   // do something with fact
///
/// case .factResponse(.failure):
///   // handle error
///
/// // ...
/// }
/// ```
///
/// ## Equality
///
/// The biggest downside to using an untyped `Error` in a result type is that the result will not
/// be equatable even if the success type is. This negatively affects your ability to test features
/// that use ``TaskResult`` in their actions with the ``TestStore``.
///
/// ``TaskResult`` does extra work to try to maintain equatability when possible. If the underlying
/// type masked by the `Error` is `Equatable`, then it will use that `Equatable` conformance
/// on two failures. Luckily, most errors thrown by Apple's frameworks are already equatable, and
/// because errors are typically simple value types, it is usually possible to have the compiler
/// synthesize a conformance for you.
///
/// If you are testing the unhappy path of a feature that feeds a ``TaskResult`` back into the
/// system, be sure to conform the error to equatable, or the test will fail:
///
/// ```swift
/// // Set up a failing dependency
/// struct RefreshFailure: Error {}
/// store.dependencies.apiClient.fetchFeed = { throw RefreshFailure() }
///
/// // Simulate pull-to-refresh
/// store.send(.refresh) { $0.isLoading = true }
///
/// // Assert against failure
/// await store.receive(.refreshResponse(.failure(RefreshFailure())) { // ðŸ›‘
///   $0.errorLabelText = "An error occurred."
///   $0.isLoading = false
/// }
/// // ðŸ›‘ 'RefreshFailure' is not equatable
/// ```
///
/// To get a passing test, explicitly conform your custom error to the `Equatable` protocol:
///
/// ```swift
/// // Set up a failing dependency
/// struct RefreshFailure: Error, Equatable {} // ðŸ‘ˆ
/// store.dependencies.apiClient.fetchFeed = { throw RefreshFailure() }
///
/// // Simulate pull-to-refresh
/// store.send(.refresh) { $0.isLoading = true }
///
/// // Assert against failure
/// await store.receive(.refreshResponse(.failure(RefreshFailure())) { // âœ…
///   $0.errorLabelText = "An error occurred."
///   $0.isLoading = false
/// }
/// ```
@available(iOS, deprecated: 9999, message: "Use 'Result', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Moving-off-of-TaskResult")
@available(macOS, deprecated: 9999, message: "Use 'Result', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Moving-off-of-TaskResult")
@available(tvOS, deprecated: 9999, message: "Use 'Result', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Moving-off-of-TaskResult")
@available(watchOS, deprecated: 9999, message: "Use 'Result', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Moving-off-of-TaskResult")
public enum TaskResult<Success> : Sendable where Success : Sendable {

    /// A success, storing a `Success` value.
    case success(Success)

    /// A failure, storing an error.
    case failure(any Error)

    /// Creates a new task result by evaluating an async throwing closure, capturing the returned
    /// value as a success, or any thrown error as a failure.
    ///
    /// This initializer is most often used in an async effect being returned from a reducer. See the
    /// documentation for ``TaskResult`` for a concrete example.
    ///
    /// - Parameter body: An async, throwing closure.
    public init(catching body: @Sendable () async throws -> Success) async

    /// Transforms a `Result` into a `TaskResult`, erasing its `Failure` to `Error`.
    ///
    /// - Parameter result: A result.
    @inlinable public init<Failure>(_ result: Result<Success, Failure>) where Failure : Error

    /// Returns the success value as a throwing property.
    @inlinable public var value: Success { get throws }

    /// Returns a new task result, mapping any success value using the given transformation.
    ///
    /// Like `map` on `Result`, `Optional`, and many other types.
    ///
    /// - Parameter transform: A closure that takes the success value of this instance.
    /// - Returns: A `TaskResult` instance with the result of evaluating `transform` as the new
    ///   success value if this instance represents a success.
    @inlinable public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> ComposableArchitecture.TaskResult<NewSuccess> where NewSuccess : Sendable

    /// Returns a new task result, mapping any success value using the given transformation and
    /// unwrapping the produced result.
    ///
    /// Like `flatMap` on `Result`, `Optional`, and many other types.
    ///
    /// - Parameter transform: A closure that takes the success value of the instance.
    /// - Returns: A `TaskResult` instance, either from the closure or the previous `.failure`.
    @inlinable public func flatMap<NewSuccess>(_ transform: (Success) -> ComposableArchitecture.TaskResult<NewSuccess>) -> ComposableArchitecture.TaskResult<NewSuccess> where NewSuccess : Sendable
}

extension TaskResult : CasePathsCore.CasePathable {

    /// A collection of all case paths of this type.
    public static var allCasePaths: ComposableArchitecture.TaskResult<Success>.AllCasePaths { get }

    /// A type that can represent a collection of all case paths of this type.
    public struct AllCasePaths {

        public var success: CasePathsCore.AnyCasePath<ComposableArchitecture.TaskResult<Success>, Success> { get }

        public var failure: CasePathsCore.AnyCasePath<ComposableArchitecture.TaskResult<Success>, any Error> { get }
    }
}

extension TaskResult : Equatable where Success : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture.TaskResult<Success>, rhs: ComposableArchitecture.TaskResult<Success>) -> Bool
}

extension TaskResult : Hashable where Success : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

/// A testable runtime for a reducer.
///
/// This object aids in writing expressive and exhaustive tests for features built in the
/// Composable Architecture. It allows you to send a sequence of actions to the store, and each step
/// of the way you must assert exactly how state changed, and how effect emissions were fed back
/// into the system.
///
/// See the dedicated <doc:TestingTCA> article for detailed information on testing.
///
/// ## Exhaustive testing
///
/// By default, ``TestStore`` requires you to exhaustively prove how your feature evolves from
/// sending use actions and receiving actions from effects. There are multiple ways the test store
/// forces you to do this:
///
///   * After each action is sent you must describe precisely how the state changed from before the
///     action was sent to after it was sent.
///
///     If even the smallest piece of data differs the test will fail. This guarantees that you are
///     proving you know precisely how the state of the system changes.
///
///   * Sending an action can sometimes cause an effect to be executed, and if that effect sends an
///     action back into the system, you **must** explicitly assert that you expect to receive that
///     action from the effect, _and_ you must assert how state changed as a result.
///
///     If you try to send another action before you have handled all effect actions, the test will
///     fail. This guarantees that you do not accidentally forget about an effect action, and that
///     the sequence of steps you are describing will mimic how the application behaves in reality.
///
///   * All effects must complete by the time the test case has finished running, and all effect
///     actions must be asserted on.
///
///     If at the end of the assertion there is still an in-flight effect running or an unreceived
///     action, the assertion will fail. This helps exhaustively prove that you know what effects
///     are in flight and forces you to prove that effects will not cause any future changes to your
///     state.
///
/// For example, given a simple counter reducer:
///
/// ```swift
/// @Reducer
/// struct Counter {
///   struct State: Equatable {
///     var count = 0
///   }
///
///   enum Action {
///     case decrementButtonTapped
///     case incrementButtonTapped
///   }
///
///   var body: some Reducer<State, Action> {
///     Reduce { state, action in
///       switch action {
///       case .decrementButtonTapped:
///         state.count -= 1
///         return .none
///
///       case .incrementButtonTapped:
///         state.count += 1
///         return .none
///       }
///     }
///   }
/// }
/// ```
///
/// One can assert against its behavior over time:
///
/// ```swift
/// @MainActor
/// struct CounterTests {
///   @Test
///   func basics() async {
///     let store = TestStore(
///       // Given: a counter state of 0
///       initialState: Counter.State(count: 0),
///     ) {
///       Counter()
///     }
///
///     // When: the increment button is tapped
///     await store.send(.incrementButtonTapped) {
///       // Then: the count should be 1
///       $0.count = 1
///     }
///   }
/// }
/// ```
///
/// Note that in the trailing closure of `.send(.incrementButtonTapped)` we are given a single
/// mutable value of the state before the action was sent, and it is our job to mutate the value to
/// match the state after the action was sent. In this case the `count` field changes to `1`.
///
/// If the change made in the closure does not reflect reality, you will get a test failure with a
/// nicely formatted failure message letting you know exactly what went wrong:
///
/// ```swift
/// await store.send(.incrementButtonTapped) {
///   $0.count = 42
/// }
/// ```
///
/// > âŒ Failure: A state change does not match expectation: â€¦
/// >
/// > ```diff
/// >  TestStoreFailureTests.State(
/// > -   count: 42
/// > +   count: 1
/// >  )
/// > ```
/// >
/// > (Expected: âˆ’, Actual: +)
///
/// For a more complex example, consider the following bare-bones search feature that uses a clock
/// and cancel token to debounce requests:
///
/// ```swift
/// @Reducer
/// struct Search {
///   struct State: Equatable {
///     var query = ""
///     var results: [String] = []
///   }
///
///   enum Action {
///     case queryChanged(String)
///     case searchResponse(Result<[String], any Error>)
///   }
///
///   @Dependency(\.apiClient) var apiClient
///   @Dependency(\.continuousClock) var clock
///   private enum CancelID { case search }
///
///   var body: some Reducer<State, Action> {
///     Reduce { state, action in
///       switch action {
///       case let .queryChanged(query):
///         state.query = query
///         return .run { send in
///           try await self.clock.sleep(for: 0.5)
///
///           await send(.searchResponse(Result { try await self.apiClient.search(query) }))
///         }
///         .cancellable(id: CancelID.search, cancelInFlight: true)
///
///       case let .searchResponse(.success(results)):
///         state.results = results
///         return .none
///
///       case .searchResponse(.failure):
///         // Do error handling here.
///         return .none
///       }
///     }
///   }
/// }
/// ```
///
/// It can be fully tested by overriding the `apiClient` and `continuousClock` dependencies with
/// values that are fully controlled and deterministic:
///
/// ```swift
/// // Create a test clock to control the timing of effects
/// let clock = TestClock()
///
/// let store = TestStore(initialState: Search.State()) {
///   Search()
/// } withDependencies: {
///   // Override the clock dependency with the test clock
///   $0.continuousClock = clock
///
///   // Simulate a search response with one item
///   $0.apiClient.search = { _ in
///     ["Composable Architecture"]
///   }
/// )
///
/// // Change the query
/// await store.send(.searchFieldChanged("c") {
///   // Assert that state updates accordingly
///   $0.query = "c"
/// }
///
/// // Advance the clock by enough to get past the debounce
/// await clock.advance(by: 0.5)
///
/// // Assert that the expected response is received
/// await store.receive(\.searchResponse.success) {
///   $0.results = ["Composable Architecture"]
/// }
/// ```
///
/// This test is proving that when the search query changes some search responses are delivered and
/// state updates accordingly.
///
/// If we did not assert that the `searchResponse` action was received, we would get the following
/// test failure:
///
/// > âŒ Failure: The store received 1 unexpected action after this one: â€¦
/// >
/// > ```
/// > Unhandled actions: [
/// >   [0]: Search.Action.searchResponse
/// > ]
/// > ```
///
/// This helpfully lets us know that we have no asserted on everything that happened in the feature,
/// which could be hiding a bug from us.
///
/// Or if we had sent another action before handling the effect's action we would have also gotten
/// a test failure:
///
/// > âŒ Failure: Must handle 1 received action before sending an action: â€¦
/// >
/// > ```
/// > Unhandled actions: [
/// >   [0]: Search.Action.searchResponse
/// > ]
/// > ```
///
/// All of these types of failures help you prove that you know exactly how your feature evolves as
/// actions are sent into the system. If the library did not produce a test failure in these
/// situations it could be hiding subtle bugs in your code. For example, when the user clears the
/// search query you probably expect that the results are cleared and no search request is executed
/// since there is no query. This can be done like so:
///
/// ```swift
/// await store.send(.queryChanged("")) {
///   $0.query = ""
///   $0.results = []
/// }
///
/// // No need to perform `store.receive` since we do not expect a search
/// // effect to execute.
/// ```
///
/// But, if in the future a bug is introduced causing a search request to be executed even when the
/// query is empty, you will get a test failure because a new effect is being created that is not
/// being asserted on. This is the power of exhaustive testing.
///
/// ## Non-exhaustive testing
///
/// While exhaustive testing can be powerful, it can also be a nuisance, especially when testing how
/// many features integrate together. This is why sometimes you may want to selectively test in a
/// non-exhaustive style.
///
/// > Tip: The concept of "non-exhaustive test store" was first introduced by
/// [Krzysztof ZabÅ‚ocki][merowing.info] in a [blog post][exhaustive-testing-in-tca] and
/// [conference talk][Composable-Architecture-at-Scale], and then later became integrated into the
/// core library.
///
/// Test stores are exhaustive by default, which means you must assert on every state change, and
/// how ever effect feeds data back into the system, and you must make sure that all effects
/// complete before the test is finished. To turn off exhaustivity you can set ``exhaustivity``
/// to ``Exhaustivity/off``. When that is done the ``TestStore``'s behavior changes:
///
///   * The trailing closures of ``send(_:assert:fileID:file:line:column:)-8f2pl`` and
///     ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk`` no longer need to assert on all
///     state changes. They can assert on any subset of changes, and only if they make an incorrect
///     mutation will a test failure be reported.
///   * The ``send(_:assert:fileID:file:line:column:)-8f2pl`` and
///     ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk`` methods are allowed to be
///     called even when actions have been received from effects that have not been asserted on yet.
///     Any pending actions will be cleared.
///   * Tests are allowed to finish with unasserted, received actions and in-flight effects. No test
///     failures will be reported.
///
/// Non-exhaustive stores can be configured to report skipped assertions by configuring
/// ``Exhaustivity/off(showSkippedAssertions:)``. When set to `true` the test store will have the
/// added behavior that any unasserted change causes a grey, informational box to appear next to
/// each assertion detailing the changes that were not asserted against. This allows you to see what
/// information you are choosing to ignore without causing a test failure. It can be useful in
/// tracking down bugs that happen in production but that aren't currently detected in tests.
///
/// This style of testing is most useful for testing the integration of multiple features where you
/// want to focus on just a certain slice of the behavior. Exhaustive testing can still be important
/// to use for leaf node features, where you truly do want to assert on everything happening inside
/// the feature.
///
/// For example, suppose you have a tab-based application where the 3rd tab is a login screen. The
/// user can fill in some data on the screen, then tap the "Submit" button, and then a series of
/// events happens to  log the user in. Once the user is logged in, the 3rd tab switches from a
/// login screen to a profile screen, _and_ the selected tab switches to the first tab, which is an
/// activity screen.
///
/// When writing tests for the login feature we will want to do that in the exhaustive style so that
/// we can prove exactly how the feature would behave in production. But, suppose we wanted to write
/// an integration test that proves after the user taps the "Login" button that ultimately the
/// selected tab switches to the first tab.
///
/// In order to test such a complex flow we must test the integration of multiple features, which
/// means dealing with complex, nested state and effects. We can emulate this flow in a test by
/// sending actions that mimic the user logging in, and then eventually assert that the selected
/// tab switched to activity:
///
/// ```swift
/// let store = TestStore(initialState: App.State()) {
///   App()
/// }
///
/// // 1ï¸âƒ£ Emulate user tapping on submit button.
/// //    (You can use case key path syntax to send actions to deeply nested features.)
/// await store.send(\.login.submitButtonTapped) {
///   // 2ï¸âƒ£ Assert how all state changes in the login feature
///   $0.login?.isLoading = true
///   â€¦
/// }
///
/// // 3ï¸âƒ£ Login feature performs API request to login, and
/// //    sends response back into system.
/// await store.receive(\.login.loginResponse.success) {
/// // 4ï¸âƒ£ Assert how all state changes in the login feature
///   $0.login?.isLoading = false
///   â€¦
/// }
///
/// // 5ï¸âƒ£ Login feature sends a delegate action to let parent
/// //    feature know it has successfully logged in.
/// await store.receive(\.login.delegate.didLogin) {
/// // 6ï¸âƒ£ Assert how all of app state changes due to that action.
///   $0.authenticatedTab = .loggedIn(
///     Profile.State(...)
///   )
///   â€¦
///   // 7ï¸âƒ£ *Finally* assert that the selected tab switches to activity.
///   $0.selectedTab = .activity
/// }
/// ```
///
/// Doing this with exhaustive testing is verbose, and there are a few problems with this:
///
///   * We need to be intimately knowledgeable in how the login feature works so that we can assert
///     on how its state changes and how its effects feed data back into the system.
///   * If the login feature were to change its logic we may get test failures here even though the
///     logic we are actually trying to test doesn't really care about those changes.
///   * This test is very long, and so if there are other similar but slightly different flows we
///     want to test we will be tempted to copy-and-paste the whole thing, leading to lots of
///     duplicated, fragile tests.
///
/// Non-exhaustive testing allows us to test the high-level flow that we are concerned with, that of
/// login causing the selected tab to switch to activity, without having to worry about what is
/// happening inside the login feature. To do this, we can turn off ``TestStore/exhaustivity`` in
/// the test store, and then just assert on what we are interested in:
///
/// ```swift
/// let store = TestStore(App.State()) {
///   App()
/// }
/// store.exhaustivity = .off  // â¬…ï¸
///
/// await store.send(\.login.submitButtonTapped)
/// await store.receive(\.login.delegate.didLogin) {
///   $0.selectedTab = .activity
/// }
/// ```
///
/// In particular, we did not assert on how the login's state changed or how the login's effects fed
/// data back into the system. We just assert that when the "Submit" button is tapped that
/// eventually we get the `didLogin` delegate action and that causes the selected tab to flip to
/// activity. Now the login feature is free to make any change it wants to make without affecting
/// this integration test.
///
/// Using ``Exhaustivity/off`` for ``TestStore/exhaustivity`` causes all un-asserted changes to pass
/// without any notification. If you would like to see what test failures are being suppressed
/// without actually causing a failure, you can use ``Exhaustivity/off(showSkippedAssertions:)``:
///
/// ```swift
/// let store = TestStore(initialState: App.State()) {
///   App()
/// }
/// store.exhaustivity = .off(showSkippedAssertions: true)  // â¬…ï¸
///
/// await store.send(\.login.submitButtonTapped)
/// await store.receive(\.login.delegate.didLogin) {
///   $0.selectedTab = .profile
/// }
/// ```
///
/// When this is run you will get grey, informational boxes on each assertion where some change
/// wasn't fully asserted on:
///
/// > â—½ï¸ Expected failure: A state change does not match expectation: â€¦
/// >
/// > ```diff
/// > â€‡ App.State(
/// > â€‡   authenticatedTab: .loggedOut(
/// >       Login.State(
/// > -       isLoading: false
/// > +       isLoading: true,
/// >         â€¦
/// >       )
/// >     )
/// > â€‡ )
/// > ```
/// >
/// > Skipped receiving .login(.loginResponse(.success))
/// >
/// > A state change does not match expectation: â€¦
/// >
/// > ```diff
/// > â€‡ App.State(
/// > -   authenticatedTab: .loggedOut(â€¦)
/// > +   authenticatedTab: .loggedIn(
/// > +     Profile.State(â€¦)
/// > +   ),
/// >     â€¦
/// > â€‡ )
/// > ```
/// >
/// > (Expected: âˆ’, Actual: +)
///
/// The test still passes, and none of these notifications are test failures. They just let you know
/// what things you are not explicitly asserting against, and can be useful to see when tracking
/// down bugs that happen in production but that aren't currently detected in tests.
///
/// [merowing.info]: https://www.merowing.info
/// [exhaustive-testing-in-tca]: https://www.merowing.info/exhaustive-testing-in-tca/
/// [Composable-Architecture-at-Scale]: https://vimeo.com/751173570
@MainActor @preconcurrency final public class TestStore<State, Action> where State : Equatable {

    /// The current dependencies of the test store.
    ///
    /// The dependencies define the execution context that your feature runs in. They can be modified
    /// throughout the test store's lifecycle in order to influence how your feature produces effects.
    ///
    /// Typically you will override certain dependencies immediately after constructing the test
    /// store. For example, if your feature need access to the current date and an API client to do
    /// its job, you can override those dependencies like so:
    ///
    /// ```swift
    /// let store = TestStore(/* ... */) {
    ///   $0.apiClient = .mock
    ///   $0.date = .constant(Date(timeIntervalSinceReferenceDate: 1234567890))
    /// }
    ///
    /// // Store assertions here
    /// ```
    ///
    /// You can also override dependencies in the middle of the test in order to simulate how the
    /// dependency changes as the user performs action. For example, to test the flow of an API
    /// request failing at first but then later succeeding, you can do the following:
    ///
    /// ```swift
    /// store.dependencies.apiClient = .failing
    ///
    /// store.send(.buttonTapped) { /* ... */ }
    /// store.receive(\.searchResponse.failure) { /* ... */ }
    ///
    /// store.dependencies.apiClient = .mock
    ///
    /// store.send(.buttonTapped) { /* ... */ }
    /// store.receive(\.searchResponse.success) { /* ... */ }
    /// ```
    @MainActor public var dependencies: Dependencies.DependencyValues

    /// The current exhaustivity level of the test store.
    @MainActor public var exhaustivity: ComposableArchitecture.Exhaustivity

    /// Serializes all async work to the main thread for the lifetime of the test store.
    @MainActor public var useMainSerialExecutor: Bool

    /// The current state of the test store.
    ///
    /// When read from a trailing closure assertion in
    /// ``send(_:assert:fileID:file:line:column:)-8f2pl`` or
    /// ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk``, it will equal the `inout` state
    /// passed to the
    /// closure.
    @MainActor public var state: State { get }

    /// The default timeout used in all methods that take an optional timeout.
    ///
    /// This is the default timeout used in all methods that take an optional timeout, such as
    /// ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk`` and
    /// ``finish(timeout:fileID:file:line:column:)-klnc``.
    @MainActor public var timeout: UInt64

    /// Returns `true` if the store's feature has been dismissed.
    @MainActor public fileprivate(set) var isDismissed: Bool { get }

    /// Creates a test store with an initial state and a reducer powering its runtime.
    ///
    /// See <doc:TestingTCA> and the documentation of ``TestStore`` for more information on how to best
    /// use a test store.
    ///
    /// - Parameters:
    ///   - initialState: The state the feature starts in.
    ///   - reducer: The reducer that powers the runtime of the feature. Unlike
    ///     ``Store/init(initialState:reducer:withDependencies:)``, this is _not_ a builder closure
    ///     due to a [Swift bug](https://github.com/apple/swift/issues/72399) that is more likely to
    ///     affect test store initialization. If you must compose multiple reducers in this closure,
    ///     wrap them in ``CombineReducers``.
    ///   - prepareDependencies: A closure that can be used to override dependencies that will be
    ///     accessed during the test. These dependencies will be used when producing the initial
    ///     state.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public init(initialState: @autoclosure () -> State, reducer: () -> some ComposableArchitecture.Reducer<State, Action>, withDependencies prepareDependencies: (inout Dependencies.DependencyValues) -> Void = { _ in }, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)

    /// Suspends until all in-flight effects have finished, or until it times out.
    ///
    /// Can be used to assert that all effects have finished.
    ///
    /// - Parameters:
    ///   - duration: The amount of time to wait before asserting.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
    @MainActor public func finish(timeout duration: Duration, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Suspends until all in-flight effects have finished, or until it times out.
    ///
    /// Can be used to assert that all effects have finished.
    ///
    /// > Important: `TestStore.finish()` should only be called once per test store, at the end of the
    /// > test. Interacting with a finished test store is undefined.
    ///
    /// - Parameters:
    ///   - nanoseconds: The amount of time to wait before asserting.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func finish(timeout nanoseconds: UInt64? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    deinit

    /// Overrides the store's dependencies for a given operation.
    ///
    /// - Parameters:
    ///   - updateValuesForOperation: A closure for updating the store's dependency values for the
    ///     duration of the operation.
    ///   - operation: The operation.
    @MainActor public func withDependencies<R>(_ updateValuesForOperation: (_ dependencies: inout Dependencies.DependencyValues) throws -> Void, operation: () throws -> R) rethrows -> R

    /// Overrides the store's dependencies for a given operation.
    ///
    /// - Parameters:
    ///   - updateValuesForOperation: A closure for updating the store's dependency values for the
    ///     duration of the operation.
    ///   - operation: The operation.
    @MainActor public func withDependencies<R>(_ updateValuesForOperation: (_ dependencies: inout Dependencies.DependencyValues) throws -> Void, operation: () async throws -> sending R) async rethrows -> R

    /// Overrides the store's exhaustivity for a given operation.
    ///
    /// - Parameters:
    ///   - exhaustivity: The exhaustivity.
    ///   - operation: The operation.
    @MainActor public func withExhaustivity<R>(_ exhaustivity: ComposableArchitecture.Exhaustivity, operation: () throws -> R) rethrows -> R

    /// Overrides the store's exhaustivity for a given operation.
    ///
    /// - Parameters:
    ///   - exhaustivity: The exhaustivity.
    ///   - operation: The operation.
    @MainActor public func withExhaustivity<R>(_ exhaustivity: ComposableArchitecture.Exhaustivity, operation: () async throws -> sending R) async rethrows -> R
}

extension TestStore {

    /// Sends an action to the store and asserts when state changes.
    ///
    /// To assert on how state changes you can provide a trailing closure, and that closure is handed
    /// a mutable variable that represents the feature's state _before_ the action was sent. You need
    /// to mutate that variable so that it is equal to the feature's state _after_ the action is sent:
    ///
    /// ```swift
    /// await store.send(.incrementButtonTapped) {
    ///   $0.count = 1
    /// }
    /// await store.send(.decrementButtonTapped) {
    ///   $0.count = 0
    /// }
    /// ```
    ///
    /// This method suspends in order to allow any effects to start. For example, if you track an
    /// analytics event in an effect when an action is sent, you can assert on that behavior
    /// immediately after awaiting `store.send`:
    ///
    /// ```swift
    /// @Test
    /// func analytics() async {
    ///   let events = LockIsolated<[String]>([])
    ///   let analytics = AnalyticsClient(
    ///     track: { event in
    ///       events.withValue { $0.append(event) }
    ///     }
    ///   )
    ///
    ///   let store = TestStore(initialState: Feature.State()) {
    ///     Feature()
    ///   } withDependencies {
    ///     $0.analytics = analytics
    ///   }
    ///
    ///   await store.send(.buttonTapped)
    ///
    ///   events.withValue { XCTAssertEqual($0, ["Button Tapped"]) }
    /// }
    /// ```
    ///
    /// This method suspends only for the duration until the effect _starts_ from sending the action.
    /// It does _not_ suspend for the duration of the effect.
    ///
    /// In order to suspend for the duration of the effect you can use its return value, a
    /// ``TestStoreTask``, which represents the lifecycle of the effect started from sending an
    /// action. You can use this value to suspend until the effect finishes, or to force the
    /// cancellation of the effect, which is helpful for effects that are tied to a view's lifecycle
    /// and not torn down when an action is sent, such as actions sent in SwiftUI's `task` view
    /// modifier.
    ///
    /// For example, if your feature kicks off a long-living effect when the view appears by using
    /// SwiftUI's `task` view modifier, then you can write a test for such a feature by explicitly
    /// canceling the effect's task after you make all assertions:
    ///
    /// ```swift
    /// let store = TestStore(/* ... */)
    ///
    /// // Emulate the view appearing
    /// let task = await store.send(.task)
    ///
    /// // Assertions
    ///
    /// // Emulate the view disappearing
    /// await task.cancel()
    /// ```
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action to
    ///     the store. The mutable state sent to this closure must be modified to match the state of
    ///     the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A ``TestStoreTask`` that represents the lifecycle of the effect executed when
    ///   sending the action.
    @discardableResult
    @MainActor public func send(_ action: Action, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async -> ComposableArchitecture.TestStoreTask

    /// Assert against the current state of the store.
    ///
    /// The trailing closure provided is given a mutable argument that represents the current state,
    /// and you can provide any mutations you want to the state. If your mutations cause the argument
    /// to differ from the current state of the test store, a test failure will be triggered.
    ///
    /// This tool is most useful in non-exhaustive test stores (see
    /// <doc:TestingTCA#Non-exhaustive-testing>), which allow you to assert on a subset of the things
    /// happening inside your features. For example, you can send an action in a child feature
    /// without asserting on how many changes in the system, and then tell the test store to
    /// ``finish(timeout:fileID:file:line:column:)-klnc`` by executing all of its effects, and finally
    /// to ``skipReceivedActions(strict:fileID:file:line:column:)`` to receive all actions. After that
    /// is done you can assert on the final state of the store:
    ///
    /// ```swift
    /// store.exhaustivity = .off
    /// await store.send(\.child.closeButtonTapped)
    /// await store.finish()
    /// await store.skipReceivedActions()
    /// store.assert {
    ///   $0.child = nil
    /// }
    /// ```
    ///
    /// > Note: This helper is only intended to be used with non-exhaustive test stores. It is not
    /// needed in exhaustive test stores since any assertion you may make inside the trailing closure
    /// has already been handled by a previous `send` or `receive`.
    ///
    /// - Parameters:
    ///   - updateStateToExpectedResult: A closure that asserts against the current state of the test
    ///   store.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func assert(_ updateStateToExpectedResult: @escaping (_ state: inout State) throws -> Void, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)
}

extension TestStore where Action : Equatable {

    /// Asserts an action was received from an effect and asserts how the state changes.
    ///
    /// When an effect is executed in your feature and sends an action back into the system, you can
    /// use this method to assert that fact, and further assert how state changes after the effect
    /// action is received:
    ///
    /// ```swift
    /// await store.send(.buttonTapped)
    /// await store.receive(.response(.success(42)) {
    ///   $0.count = 42
    /// }
    /// ```
    ///
    /// Due to the variability of concurrency in Swift, sometimes a small amount of time needs to pass
    /// before effects execute and send actions, and that is why this method suspends. The default
    /// time waited is very small, and typically it is enough so you should be controlling your
    /// dependencies so that they do not wait for real world time to pass (see
    /// <doc:DependencyManagement> for more information on how to do that).
    ///
    /// To change the amount of time this method waits for an action, pass an explicit `timeout`
    /// argument, or set the ``timeout`` on the ``TestStore``.
    ///
    /// - Parameters:
    ///   - expectedAction: An action expected from an effect.
    ///   - duration: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action
    ///     to the store. The mutable state sent to this closure must be modified to match the state
    ///     of the store after processing the given action. Do not provide a closure if no change
    ///     is expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
    @MainActor public func receive(_ expectedAction: Action, timeout duration: Duration, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts an action was received from an effect and asserts how the state changes.
    ///
    /// When an effect is executed in your feature and sends an action back into the system, you can
    /// use this method to assert that fact, and further assert how state changes after the effect
    /// action is received:
    ///
    /// ```swift
    /// await store.send(.buttonTapped)
    /// await store.receive(.response(.success(42)) {
    ///   $0.count = 42
    /// }
    /// ```
    ///
    /// Due to the variability of concurrency in Swift, sometimes a small amount of time needs to pass
    /// before effects execute and send actions, and that is why this method suspends. The default
    /// time waited is very small, and typically it is enough so you should be controlling your
    /// dependencies so that they do not wait for real world time to pass (see
    /// <doc:DependencyManagement> for more information on how to do that).
    ///
    /// To change the amount of time this method waits for an action, pass an explicit `timeout`
    /// argument, or set the ``timeout`` on the ``TestStore``.
    ///
    /// - Parameters:
    ///   - expectedAction: An action expected from an effect.
    ///   - nanoseconds: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action to
    ///     the store. The mutable state sent to this closure must be modified to match the state of
    ///     the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func receive(_ expectedAction: Action, timeout nanoseconds: UInt64? = nil, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async
}

extension TestStore {

    /// Asserts an action was received from an effect that matches a predicate, and asserts how the
    /// state changes.
    ///
    /// This method is similar to ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk``, except
    /// it allows you to assert that an action was received that matches a predicate instead of a case
    /// key path:
    ///
    /// ```swift
    /// await store.send(.buttonTapped)
    /// await store.receive {
    ///   guard case .response(.success) = $0 else { return false }
    ///   return true
    /// } assert: {
    ///   store.count = 42
    /// }
    /// ```
    ///
    /// When the store's ``exhaustivity`` is set to anything other than ``Exhaustivity/off``, a grey
    /// information box will show next to the `store.receive` line in Xcode letting you know what data
    /// was in the effect that you chose not to assert on.
    ///
    /// If you only want to check that a particular action case was received, then you might find the
    /// ``receive(_:timeout:assert:fileID:file:line:column:)-53wic`` overload of this method more
    /// useful.
    ///
    /// - Parameters:
    ///   - isMatching: A closure that attempts to match an action. If it returns `false`, a test
    ///     failure is reported.
    ///   - duration: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action
    ///     to the store. The mutable state sent to this closure must be modified to match the state
    ///     of the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
    @MainActor public func receive(_ isMatching: (_ action: Action) -> Bool, timeout duration: Duration, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts an action was received from an effect that matches a predicate, and asserts how the
    /// state changes.
    ///
    /// This method is similar to ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk``, except
    /// it allows you to assert that an action was received that matches a predicate instead of a case
    /// key path:
    ///
    /// ```swift
    /// await store.send(.buttonTapped)
    /// await store.receive {
    ///   guard case .response(.success) = $0 else { return false }
    ///   return true
    /// } assert: {
    ///   store.count = 42
    /// }
    /// ```
    ///
    /// When the store's ``exhaustivity`` is set to anything other than ``Exhaustivity/off``, a grey
    /// information box will show next to the `store.receive` line in Xcode letting you know what data
    /// was in the effect that you chose not to assert on.
    ///
    /// If you only want to check that a particular action case was received, then you might find the
    /// ``receive(_:timeout:assert:fileID:file:line:column:)-53wic`` overload of this method more
    /// useful.
    ///
    /// - Parameters:
    ///   - isMatching: A closure that attempts to match an action. If it returns `false`, a test
    ///     failure is reported.
    ///   - nanoseconds: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action to
    ///     the store. The mutable state sent to this closure must be modified to match the state of
    ///     the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func receive(_ isMatching: (_ action: Action) -> Bool, timeout nanoseconds: UInt64? = nil, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts an action was received matching a case path and asserts how the state changes.
    ///
    /// This method is similar to ``receive(_:timeout:assert:fileID:file:line:column:)-35638``, except
    /// it allows you to assert that an action was received that matches a case key path instead of a
    /// predicate.
    ///
    /// It can be useful to assert that a particular action was received without asserting on the data
    /// inside the action. For example:
    ///
    /// ```swift
    /// await store.receive(/Search.Action.searchResponse) {
    ///   $0.results = [
    ///     "CasePaths",
    ///     "ComposableArchitecture",
    ///     "IdentifiedCollections",
    ///     "XCTestDynamicOverlay",
    ///   ]
    /// }
    /// ```
    ///
    /// When the store's ``exhaustivity`` is set to anything other than ``Exhaustivity/off``, a grey
    /// information box will show next to the `store.receive` line in Xcode letting you know what data
    /// was in the effect that you chose not to assert on.
    ///
    /// - Parameters:
    ///   - actionCase: A case path identifying the case of an action to enum to receive
    ///   - nanoseconds: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action to
    ///     the store. The mutable state sent to this closure must be modified to match the state of
    ///     the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func receive<Value>(_ actionCase: CasePathsCore.CaseKeyPath<Action, Value>, timeout nanoseconds: UInt64? = nil, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts an action was received matching a case path with a specific payload, and asserts how
    /// the state changes.
    ///
    /// This method is similar to ``receive(_:timeout:assert:fileID:file:line:column:)-53wic``, except
    /// it allows you to assert on the value inside the action too.
    ///
    /// It can be useful when asserting on delegate actions sent by a child feature:
    ///
    /// ```swift
    /// await store.receive(\.delegate.success, "Hello!")
    /// ```
    ///
    /// When the store's ``exhaustivity`` is set to anything other than ``Exhaustivity/off``, a grey
    /// information box will show next to the `store.receive` line in Xcode letting you know what data
    /// was in the effect that you chose not to assert on.
    ///
    /// - Parameters:
    ///   - actionCase: A case path identifying the case of an action to enum to receive
    ///   - value: The value to match in the action.
    ///   - nanoseconds: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action
    ///     to the store. The mutable state sent to this closure must be modified to match the state
    ///     of the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func receive<Value>(_ actionCase: CasePathsCore.CaseKeyPath<Action, Value>, _ value: Value, timeout nanoseconds: UInt64? = nil, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async where Action : CasePathsCore.CasePathable, Value : Equatable

    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @MainActor public func receive<Value>(_ actionCase: CasePathsCore.AnyCasePath<Action, Value>, timeout nanoseconds: UInt64? = nil, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts an action was received matching a case path and asserts how the state changes.
    ///
    /// This method is similar to ``receive(_:timeout:assert:fileID:file:line:column:)-8zqxk``, except
    /// it allows you to assert that an action was received that matches a case key path instead of a
    /// predicate.
    ///
    /// It can be useful to assert that a particular action was received without asserting on the data
    /// inside the action. For example:
    ///
    /// ```swift
    /// await store.receive(\.searchResponse) {
    ///   $0.results = [
    ///     "CasePaths",
    ///     "ComposableArchitecture",
    ///     "IdentifiedCollections",
    ///     "XCTestDynamicOverlay",
    ///   ]
    /// }
    /// ```
    ///
    /// When the store's ``exhaustivity`` is set to anything other than ``Exhaustivity/off``, a grey
    /// information box will show next to the `store.receive` line in Xcode letting you know what data
    /// was in the effect that you chose not to assert on.
    ///
    /// - Parameters:
    ///   - actionCase: A case path identifying the case of an action to enum to receive
    ///   - duration: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action
    ///     to the store. The mutable state sent to this closure must be modified to match the state
    ///     of the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
    @MainActor public func receive<Value>(_ actionCase: CasePathsCore.CaseKeyPath<Action, Value>, timeout duration: Duration, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts an action was received matching a case path with a specific payload, and asserts how
    /// the state changes.
    ///
    /// This method is similar to ``receive(_:timeout:assert:fileID:file:line:column:)-53wic``, except
    /// it allows you to assert on the value inside the action too.
    ///
    /// It can be useful when asserting on delegate actions sent by a child feature:
    ///
    /// ```swift
    /// await store.receive(\.delegate.success, "Hello!")
    /// ```
    ///
    /// When the store's ``exhaustivity`` is set to anything other than ``Exhaustivity/off``, a grey
    /// information box will show next to the `store.receive` line in Xcode letting you know what data
    /// was in the effect that you chose not to assert on.
    ///
    /// - Parameters:
    ///   - actionCase: A case path identifying the case of an action to enum to receive
    ///   - value: The value to match in the action.
    ///   - duration: The amount of time to wait for the expected action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action
    ///     to the store. The mutable state sent to this closure must be modified to match the state
    ///     of the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
    @MainActor public func receive<Value>(_ actionCase: ComposableArchitecture._SendableCaseKeyPath<Action, Value>, _ value: Value, timeout duration: Duration, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async where Action : CasePathsCore.CasePathable, Value : Equatable, Value : Sendable

    @available(iOS, introduced: 16, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, introduced: 13, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, introduced: 16, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, introduced: 9, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @MainActor public func receive<Value>(_ actionCase: CasePathsCore.AnyCasePath<Action, Value>, timeout duration: Duration, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async
}

extension TestStore {

    /// Sends an action to the store and asserts when state changes.
    ///
    /// This method is similar to ``send(_:assert:fileID:file:line:column:)-8f2pl``, except it allows
    /// you to specify a case key path to an action, which can be useful when testing the integration
    /// of features and sending deeply nested actions. For example:
    ///
    /// ```swift
    /// await store.send(.destination(.presented(.child(.tap))))
    /// ```
    ///
    /// â€¦can be simplified to:
    ///
    /// ```swift
    /// await store.send(\.destination.child.tap)
    /// ```
    ///
    /// - Parameters:
    ///   - action: A case key path to an action.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action to
    ///     the store. The mutable state sent to this closure must be modified to match the state of
    ///     the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A ``TestStoreTask`` that represents the lifecycle of the effect executed when
    ///   sending the action.
    @discardableResult
    @MainActor public func send(_ action: CasePathsCore.CaseKeyPath<Action, Void>, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async -> ComposableArchitecture.TestStoreTask

    /// Sends an action to the store and asserts when state changes.
    ///
    /// This method is similar to ``send(_:assert:fileID:file:line:column:)-8f2pl``, except it allows
    /// you to specify a value for the associated value of the action.
    ///
    /// It can be useful when sending nested action.  For example:
    ///
    /// ```swift
    /// await store.send(.destination(.presented(.child(.emailChanged("blob@pointfree.co")))))
    /// ```
    ///
    /// â€¦can be simplified to:
    ///
    /// ```swift
    /// await store.send(\.destination.child.emailChanged, "blob@pointfree.co")
    /// ```
    ///
    /// - Parameters:
    ///   - action: A case key path to an action.
    ///   - value: A value to embed in `action`.
    ///   - updateStateToExpectedResult: A closure that asserts state changed by sending the action to
    ///     the store. The mutable state sent to this closure must be modified to match the state of
    ///     the store after processing the given action. Do not provide a closure if no change is
    ///     expected.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A ``TestStoreTask`` that represents the lifecycle of the effect executed when
    ///   sending the action.
    @discardableResult
    @MainActor public func send<Value>(_ action: CasePathsCore.CaseKeyPath<Action, Value>, _ value: Value, assert updateStateToExpectedResult: ((_ state: inout State) throws -> Void)? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async -> ComposableArchitecture.TestStoreTask
}

extension TestStore {

    /// Clears the queue of received actions from effects.
    ///
    /// Can be handy if you are writing an exhaustive test for a particular part of your feature, but
    /// you don't want to explicitly deal with all of the received actions:
    ///
    /// ```swift
    /// let store = TestStore(/* ... */)
    ///
    /// await store.send(.buttonTapped) {
    ///   // Assert on how state changed
    /// }
    /// await store.receive(\.response) {
    ///   // Assert on how state changed
    /// }
    ///
    /// // Make it explicit you do not want to assert on any other received actions.
    /// await store.skipReceivedActions()
    /// ```
    ///
    /// - Parameters:
    ///   - strict: When `true` and there are no in-flight actions to cancel, a test failure
    ///     will be reported.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func skipReceivedActions(strict: Bool = true, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Cancels any currently in-flight effects.
    ///
    /// Can be handy if you are writing an exhaustive test for a particular part of your feature, but
    /// you don't want to explicitly deal with all effects:
    ///
    /// ```swift
    /// let store = TestStore(/* ... */)
    ///
    /// await store.send(.buttonTapped) {
    ///   // Assert on how state changed
    /// }
    /// await store.receive(\.response) {
    ///   // Assert on how state changed
    /// }
    ///
    /// // Make it explicit you do not want to assert on how any other effects behave.
    /// await store.skipInFlightEffects()
    /// ```
    ///
    /// - Parameters:
    ///   - strict: When `true` and there are no in-flight actions to cancel, a test failure
    ///   will be reported.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public func skipInFlightEffects(strict: Bool = true, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async
}

extension TestStore {

    /// Returns a binding view store for this store.
    ///
    /// Useful for testing view state of a store.
    ///
    /// ```swift
    /// let store = TestStore(LoginFeature.State()) {
    ///   Login.Feature()
    /// }
    /// await store.send(.view(.set(\.$email, "blob@pointfree.co"))) {
    ///   $0.email = "blob@pointfree.co"
    /// }
    /// XCTAssertTrue(
    ///   LoginView.ViewState(store.bindings(action: \.view))
    ///     .isLoginButtonDisabled
    /// )
    ///
    /// await store.send(.view(.set(\.$password, "whats-the-point?"))) {
    ///   $0.password = "blob@pointfree.co"
    ///   $0.isFormValid = true
    /// }
    /// XCTAssertFalse(
    ///   LoginView.ViewState(store.bindings(action: \.view))
    ///     .isLoginButtonDisabled
    /// )
    /// ```
    ///
    /// - Parameter toViewAction: A case path from action to a bindable view action.
    /// - Returns: A binding view store.
    @MainActor public func bindings<ViewAction>(action toViewAction: CasePathsCore.CaseKeyPath<Action, ViewAction>) -> ComposableArchitecture.BindingViewStore<State> where State == ViewAction.State, Action : CasePathsCore.CasePathable, ViewAction : ComposableArchitecture.BindableAction

    @available(iOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(macOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(tvOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @available(watchOS, deprecated: 9999, message: "Use the version of this operator with case key paths, instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.4#Using-case-key-paths")
    @MainActor public func bindings<ViewAction>(action toViewAction: CasePathsCore.AnyCasePath<Action, ViewAction>) -> ComposableArchitecture.BindingViewStore<State> where State == ViewAction.State, ViewAction : ComposableArchitecture.BindableAction
}

extension TestStore where State == Action.State, Action : ComposableArchitecture.BindableAction {

    /// Returns a binding view store for this store.
    ///
    /// Useful for testing view state of a store.
    ///
    /// ```swift
    /// let store = TestStore(LoginFeature.State()) {
    ///   Login.Feature()
    /// }
    /// await store.send(.set(\.$email, "blob@pointfree.co")) {
    ///   $0.email = "blob@pointfree.co"
    /// }
    /// XCTAssertTrue(LoginView.ViewState(store.bindings).isLoginButtonDisabled)
    ///
    /// await store.send(.set(\.$password, "whats-the-point?")) {
    ///   $0.password = "blob@pointfree.co"
    ///   $0.isFormValid = true
    /// }
    /// XCTAssertFalse(LoginView.ViewState(store.bindings).isLoginButtonDisabled)
    /// ```
    ///
    /// - Returns: A binding view store.
    @MainActor public var bindings: ComposableArchitecture.BindingViewStore<State> { get }
}

/// A convenience type alias for referring to a test store of a given reducer's domain.
///
/// Instead of specifying two generics:
///
/// ```swift
/// let testStore: TestStore<Feature.State, Feature.Action>
/// ```
///
/// You can specify a single generic:
///
/// ```swift
/// let testStore: TestStoreOf<Feature>
/// ```
public typealias TestStoreOf<R> = ComposableArchitecture.TestStore<R.State, R.Action> where R : ComposableArchitecture.Reducer, R.State : Equatable

/// The type returned from ``TestStore/send(_:assert:fileID:file:line:column:)-8f2pl`` that represents the
/// lifecycle of the effect started from sending an action.
///
/// You can use this value in tests to cancel the effect started from sending an action:
///
/// ```swift
/// // Simulate the "task" view modifier invoking some async work
/// let task = store.send(.task)
///
/// // Simulate the view cancelling this work on dismissal
/// await task.cancel()
/// ```
///
/// You can also explicitly wait for an effect to finish:
///
/// ```swift
/// store.send(.startTimerButtonTapped)
///
/// await mainQueue.advance(by: .seconds(1))
/// await store.receive(\.timerTick) { $0.elapsed = 1 }
///
/// // Wait for cleanup effects to finish before completing the test
/// await store.send(.stopTimerButtonTapped).finish()
/// ```
///
/// See ``TestStore/finish(timeout:fileID:file:line:column:)-klnc`` for the ability to await all
/// in-flight effects in the test store.
///
/// See ``StoreTask`` for the analog provided to ``Store``.
public struct TestStoreTask : Hashable, Sendable {

    public init(rawValue: Task<Void, Never>?, timeout: UInt64)

    /// Cancels the underlying task and waits for it to finish.
    ///
    /// This can be handy when a feature needs to start a long-living effect when the feature appears,
    /// but cancellation of that effect is handled by the parent when the feature disappears. Such a
    /// feature is difficult to exhaustively test in isolation because there is no action in its
    /// domain that cancels the effect:
    ///
    /// ```swift
    /// let store = TestStore(/* ... */)
    ///
    /// let onAppearTask = await store.send(.onAppear)
    /// // Assert what is happening in the feature
    ///
    /// await onAppearTask.cancel() // âœ… Cancel the task to simulate the feature disappearing.
    /// ```
    public func cancel() async

    /// Asserts the underlying task finished.
    ///
    /// - Parameters:
    ///   - duration: The amount of time to wait before asserting.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
    public func finish(timeout duration: Duration, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// Asserts the underlying task finished.
    ///
    /// - Parameters:
    ///   - nanoseconds: The amount of time to wait before asserting.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    public func finish(timeout nanoseconds: UInt64? = nil, fileID: StaticString = #fileID, file filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) async

    /// A Boolean value that indicates whether the task should stop executing.
    ///
    /// After the value of this property becomes `true`, it remains `true` indefinitely. There is
    /// no way to uncancel a task.
    public var isCancelled: Bool { get }
}

/// Defines the actions that can be sent from a view.
///
/// See the ``ViewAction(for:)`` macro for more information on how to use this.
public protocol ViewAction<ViewAction> {

    associatedtype ViewAction

    static func view(_ action: Self.ViewAction) -> Self
}

/// Provides a view with access to a feature's ``ViewAction``s.
///
/// If you want to restrict what actions can be sent from the view you can use this macro along with the
/// ``ViewAction`` protocol. You start by conforming your reducer's `Action` enum to the
/// ``ViewAction`` protocol, and moving view-specific actions to its own inner enum:
///
/// ```swift
/// @Reducer
/// struct Feature {
///   struct State { /* ... */ }
///   enum Action: ViewAction {
///     case loginResponse(Bool)
///     case view(View)
///
///     enum View {
///       case loginButtonTapped
///     }
///   }
///   // ...
/// }
/// ```
///
/// Then you can apply the ``ViewAction(for:)`` macro to your view by specifying the type of the
/// reducer that powers the view:
///
/// ```swift
/// @ViewAction(for: Feature.self)
/// struct FeatureView: View {
///   let store: StoreOf<Feature>
///   // ...
/// }
/// ```
///
/// The macro does two things:
///
/// * It adds a `send` method to the view that you can use instead of `store.send`. This allows you
///   to send view actions more simply, without wrapping the action in `.view(â€¦)`:
///   ```diff
///    Button("Login") {
///   -  store.send(.view(.loginButtonTapped))
///   +  send(.loginButtonTapped)
///    }
///   ```
/// * It creates warning diagnostics if you try sending actions through `store.send` rather than
///   using the `send` method on the view:
///   ```swift
///   Button("Login") {
///     store.send(.view(.loginButtonTapped))
///   //â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€
///   //â•°â”€ âš ï¸ Do not use 'store.send' directly when using '@ViewAction'
///   }
///   ```
@attached(extension, conformances: ComposableArchitecture.ViewActionSending) public macro ViewAction<R>(for: R.Type) = #externalMacro(module: "ComposableArchitectureMacros", type: "ViewActionMacro") where R : ComposableArchitecture.Reducer, R.Action : ComposableArchitecture.ViewAction

/// A type that represents a view with a ``Store`` that can send ``ViewAction``s.
@MainActor @preconcurrency public protocol ViewActionSending<StoreState, StoreAction> {

    associatedtype StoreState

    associatedtype StoreAction : ComposableArchitecture.ViewAction

    @MainActor var store: ComposableArchitecture.Store<Self.StoreState, Self.StoreAction> { get }
}

extension ViewActionSending {

    /// Send a view action to the store.
    @discardableResult
    @MainActor public func send(_ action: Self.StoreAction.ViewAction) -> ComposableArchitecture.StoreTask

    /// Send a view action to the store with animation.
    @discardableResult
    @MainActor public func send(_ action: Self.StoreAction.ViewAction, animation: Animation?) -> ComposableArchitecture.StoreTask

    /// Send a view action to the store with a transaction.
    @discardableResult
    @MainActor public func send(_ action: Self.StoreAction.ViewAction, transaction: Transaction) -> ComposableArchitecture.StoreTask
}

/// A `ViewStore` is an object that can observe state changes and send actions. They are most
/// commonly used in views, such as SwiftUI views, UIView or UIViewController, but they can be used
/// anywhere it makes sense to observe state or send actions.
///
/// In SwiftUI applications, a `ViewStore` is accessed most commonly using the ``WithViewStore``
/// view. It can be initialized with a store and a closure that is handed a view store and returns a
/// view:
///
/// ```swift
/// var body: some View {
///   WithViewStore(self.store, observe: { $0 }) { viewStore in
///     VStack {
///       Text("Current count: \(viewStore.count)")
///       Button("Increment") { viewStore.send(.incrementButtonTapped) }
///     }
///   }
/// }
/// ```
///
/// View stores can also be observed directly by views, scenes, commands, and other contexts that
/// support the `@ObservedObject` property wrapper:
///
/// ```swift
/// @ObservedObject var viewStore: ViewStore<State, Action>
/// ```
///
/// > Tip: If you experience compile-time issues with views that use ``WithViewStore``, try
/// > observing the view store directly using the `@ObservedObject` property wrapper, instead, which
/// > is easier on the compiler.
///
/// In UIKit applications a `ViewStore` can be created from a ``Store`` and then subscribed to for
/// state updates:
///
/// ```swift
/// let store: Store<State, Action>
/// let viewStore: ViewStore<State, Action>
/// private var cancellables: Set<AnyCancellable> = []
///
/// init(store: Store<State, Action>) {
///   self.store = store
///   self.viewStore = ViewStore(store, observe: { $0 })
/// }
///
/// func viewDidLoad() {
///   super.viewDidLoad()
///
///   self.viewStore.publisher.count
///     .sink { [weak self] in self?.countLabel.text = $0 }
///     .store(in: &self.cancellables)
/// }
///
/// @objc func incrementButtonTapped() {
///   self.viewStore.send(.incrementButtonTapped)
/// }
/// ```
@available(iOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@available(macOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@available(tvOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@available(watchOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@MainActor @dynamicMemberLookup @preconcurrency final public class ViewStore<ViewState, ViewAction> : ObservableObject {

    /// A publisher that emits before the object has changed.
    nonisolated public let objectWillChange: ObservableObjectPublisher

    /// Initializes a view store from a store which observes changes to state.
    ///
    /// It is recommended that the `observe` argument transform the store's state into the bare
    /// minimum of data needed for the feature to do its job in order to not hinder performance.
    /// This is especially true for root level features, and less important for leaf features.
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A transformation of `ViewState` to the state that will be observed for
    ///   changes.
    ///   - isDuplicate: A function to determine when two `State` values are equal. When values are
    ///   equal, repeat view computations are removed.
    @MainActor public convenience init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: State) -> ViewState, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool)

    /// Initializes a view store from a store which observes changes to state.
    ///
    /// It is recommended that the `observe` argument transform the store's state into the bare
    /// minimum of data needed for the feature to do its job in order to not hinder performance.
    /// This is especially true for root level features, and less important for leaf features.
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A transformation of `ViewState` to the state that will be observed for
    ///   changes.
    ///   - fromViewAction: A transformation of `ViewAction` that describes what actions can be sent.
    ///   - isDuplicate: A function to determine when two `State` values are equal. When values are
    ///   equal, repeat view computations are removed.
    @MainActor public init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: State) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool)

    deinit

    /// A publisher that emits when state changes.
    ///
    /// This publisher supports dynamic member lookup so that you can pluck out a specific field in
    /// the state:
    ///
    /// ```swift
    /// viewStore.publisher.alert
    ///   .sink { ... }
    /// ```
    ///
    /// When the emission happens the ``ViewStore``'s state has been updated, and so the following
    /// precondition will pass:
    ///
    /// ```swift
    /// viewStore.publisher
    ///   .sink { precondition($0 == viewStore.state) }
    /// ```
    ///
    /// This means you can either use the value passed to the closure or you can reach into
    /// `viewStore.state` directly.
    ///
    /// - Note: Due to a bug in Combine (or feature?), the order you `.sink` on a publisher has no
    ///   bearing on the order the `.sink` closures are called. This means the work performed inside
    ///   `viewStore.publisher.sink` closures should be completely independent of each other. Later
    ///   closures cannot assume that earlier ones have already run.
    @MainActor public var publisher: ComposableArchitecture.StorePublisher<ViewState> { get }

    /// The current state.
    @MainActor public var state: ViewState { get }

    /// Returns the resulting value of a given key path.
    @MainActor public subscript<Value>(dynamicMember keyPath: KeyPath<ViewState, Value>) -> Value { get }

    /// Sends an action to the store.
    ///
    /// This method returns a ``StoreTask``, which represents the lifecycle of the effect started
    /// from sending an action. You can use this value to tie the effect's lifecycle _and_
    /// cancellation to an asynchronous context, such as SwiftUI's `task` view modifier:
    ///
    /// ```swift
    /// .task { await viewStore.send(.task).finish() }
    /// ```
    ///
    /// > Important: ``ViewStore`` is not thread safe and you should only send actions to it from the
    /// > main thread. If you want to send actions on background threads due to the fact that the
    /// > reducer is performing computationally expensive work, then a better way to handle this is to
    /// > wrap that work in an ``Effect`` that is performed on a background thread so that the
    /// > result can be fed back into the store.
    ///
    /// - Parameter action: An action.
    /// - Returns: A ``StoreTask`` that represents the lifecycle of the effect executed when
    ///   sending the action.
    @discardableResult
    @MainActor public func send(_ action: ViewAction) -> ComposableArchitecture.StoreTask

    /// Sends an action to the store with a given animation.
    ///
    /// See ``ViewStore/send(_:)`` for more info.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - animation: An animation.
    @discardableResult
    @MainActor public func send(_ action: ViewAction, animation: Animation?) -> ComposableArchitecture.StoreTask

    /// Sends an action to the store with a given transaction.
    ///
    /// See ``ViewStore/send(_:)`` for more info.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - transaction: A transaction.
    @discardableResult
    @MainActor public func send(_ action: ViewAction, transaction: Transaction) -> ComposableArchitecture.StoreTask

    /// Sends an action into the store and then suspends while a piece of state is `true`.
    ///
    /// This method can be used to interact with async/await code, allowing you to suspend while work
    /// is being performed in an effect. One common example of this is using SwiftUI's `.refreshable`
    /// method, which shows a loading indicator on the screen while work is being performed.
    ///
    /// For example, suppose we wanted to load some data from the network when a pull-to-refresh
    /// gesture is performed on a list. The domain and logic for this feature can be modeled like so:
    ///
    /// ```swift
    /// @Reducer
    /// struct Feature {
    ///   struct State: Equatable {
    ///     var isLoading = false
    ///     var response: String?
    ///   }
    ///   enum Action {
    ///     case pulledToRefresh
    ///     case receivedResponse(Result<String, any Error>)
    ///   }
    ///   @Dependency(\.fetch) var fetch
    ///
    ///   var body: some Reducer<State, Action> {
    ///     Reduce { state, action in
    ///       switch action {
    ///       case .pulledToRefresh:
    ///         state.isLoading = true
    ///         return .run { send in
    ///           await send(.receivedResponse(Result { try await self.fetch() }))
    ///         }
    ///
    ///       case let .receivedResponse(result):
    ///         state.isLoading = false
    ///         state.response = try? result.value
    ///         return .none
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Note that we keep track of an `isLoading` boolean in our state so that we know exactly when
    /// the network response is being performed.
    ///
    /// The view can show the fact in a `List`, if it's present, and we can use the `.refreshable`
    /// view modifier to enhance the list with pull-to-refresh capabilities:
    ///
    /// ```swift
    /// struct MyView: View {
    ///   let store: Store<State, Action>
    ///
    ///   var body: some View {
    ///     WithViewStore(self.store, observe: { $0 }) { viewStore in
    ///       List {
    ///         if let response = viewStore.response {
    ///           Text(response)
    ///         }
    ///       }
    ///       .refreshable {
    ///         await viewStore.send(.pulledToRefresh, while: \.isLoading)
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Here we've used the ``send(_:while:)`` method to suspend while the `isLoading` state is
    /// `true`. Once that piece of state flips back to `false` the method will resume, signaling to
    /// `.refreshable` that the work has finished which will cause the loading indicator to disappear.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - predicate: A predicate on `ViewState` that determines for how long this method should
    ///     suspend.
    @MainActor public func send(_ action: ViewAction, while predicate: @escaping (_ state: ViewState) -> Bool) async

    /// Sends an action into the store and then suspends while a piece of state is `true`.
    ///
    /// See the documentation of ``send(_:while:)`` for more information.
    ///
    /// - Parameters:
    ///   - action: An action.
    ///   - animation: The animation to perform when the action is sent.
    ///   - predicate: A predicate on `ViewState` that determines for how long this method should
    ///     suspend.
    @MainActor public func send(_ action: ViewAction, animation: Animation?, while predicate: @escaping (_ state: ViewState) -> Bool) async

    /// Suspends the current task while a predicate on state is `true`.
    ///
    /// If you want to suspend at the same time you send an action to the view store, use
    /// ``send(_:while:)``.
    ///
    /// - Parameter predicate: A predicate on `ViewState` that determines for how long this method
    ///   should suspend.
    @MainActor public func yield(while predicate: @escaping (_ state: ViewState) -> Bool) async

    /// Derives a binding from the store that prevents direct writes to state and instead sends
    /// actions to the store.
    ///
    /// The method is useful for dealing with SwiftUI components that work with two-way `Binding`s
    /// since the ``Store`` does not allow directly writing its state; it only allows reading state
    /// and sending actions.
    ///
    /// For example, a text field binding can be created like this:
    ///
    /// ```swift
    /// struct State { var name = "" }
    /// enum Action { case nameChanged(String) }
    ///
    /// TextField(
    ///   "Enter name",
    ///   text: viewStore.binding(
    ///     get: { $0.name },
    ///     send: { Action.nameChanged($0) }
    ///   )
    /// )
    /// ```
    ///
    /// - Parameters:
    ///   - get: A function to get the state for the binding from the view store's full state.
    ///   - valueToAction: A function that transforms the binding's value into an action that can be
    ///     sent to the store.
    /// - Returns: A binding.
    @MainActor public func binding<Value>(get: @escaping (_ state: ViewState) -> Value, send valueToAction: @escaping (_ value: Value) -> ViewAction) -> Binding<Value>

    /// Derives a binding from the store that prevents direct writes to state and instead sends
    /// actions to the store.
    ///
    /// The method is useful for dealing with SwiftUI components that work with two-way `Binding`s
    /// since the ``Store`` does not allow directly writing its state; it only allows reading state
    /// and sending actions.
    ///
    /// For example, an alert binding can be dealt with like this:
    ///
    /// ```swift
    /// struct State { var alert: String? }
    /// enum Action { case alertDismissed }
    ///
    /// .alert(
    ///   item: viewStore.binding(
    ///     get: { $0.alert },
    ///     send: .alertDismissed
    ///   )
    /// ) { alert in Alert(title: Text(alert.message)) }
    /// ```
    ///
    /// - Parameters:
    ///   - get: A function to get the state for the binding from the view store's full state.
    ///   - action: The action to send when the binding is written to.
    /// - Returns: A binding.
    @MainActor public func binding<Value>(get: @escaping (_ state: ViewState) -> Value, send action: ViewAction) -> Binding<Value>

    /// Derives a binding from the store that prevents direct writes to state and instead sends
    /// actions to the store.
    ///
    /// The method is useful for dealing with SwiftUI components that work with two-way `Binding`s
    /// since the ``Store`` does not allow directly writing its state; it only allows reading state
    /// and sending actions.
    ///
    /// For example, a text field binding can be created like this:
    ///
    /// ```swift
    /// typealias State = String
    /// enum Action { case nameChanged(String) }
    ///
    /// TextField(
    ///   "Enter name",
    ///   text: viewStore.binding(
    ///     send: { Action.nameChanged($0) }
    ///   )
    /// )
    /// ```
    ///
    /// - Parameters:
    ///   - valueToAction: A function that transforms the binding's value into an action that can be
    ///     sent to the store.
    /// - Returns: A binding.
    @MainActor public func binding(send valueToAction: @escaping (_ state: ViewState) -> ViewAction) -> Binding<ViewState>

    /// Derives a binding from the store that prevents direct writes to state and instead sends
    /// actions to the store.
    ///
    /// The method is useful for dealing with SwiftUI components that work with two-way `Binding`s
    /// since the ``Store`` does not allow directly writing its state; it only allows reading state
    /// and sending actions.
    ///
    /// For example, an alert binding can be dealt with like this:
    ///
    /// ```swift
    /// typealias State = String
    /// enum Action { case alertDismissed }
    ///
    /// .alert(
    ///   item: viewStore.binding(
    ///     send: .alertDismissed
    ///   )
    /// ) { title in Alert(title: Text(title)) }
    /// ```
    ///
    /// - Parameters:
    ///   - action: The action to send when the binding is written to.
    /// - Returns: A binding.
    @MainActor public func binding(send action: ViewAction) -> Binding<ViewState>
}

extension ViewStore where ViewState == ViewAction.State, ViewAction : ComposableArchitecture.BindableAction {

    @MainActor public subscript<Value>(dynamicMember keyPath: WritableKeyPath<ViewState, ComposableArchitecture.BindingState<Value>>) -> Binding<Value> where Value : Equatable, Value : Sendable { get }
}

extension ViewStore {

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - fromViewAction: A function that transforms view actions into store action.
    ///   - isDuplicate: A function to determine when two `ViewState` values are equal. When values
    ///     are equal, repeat view computations are removed.
    @MainActor public convenience init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - isDuplicate: A function to determine when two `ViewState` values are equal. When values
    ///     are equal, repeat view computations are removed.
    @MainActor public convenience init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State
}

extension ViewStore where ViewState : Equatable {

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - fromViewAction: A function that transforms view actions into store action.
    @MainActor public convenience init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    @MainActor public convenience init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State
}

extension ViewStore where ViewState : Equatable {

    /// Initializes a view store from a store which observes changes to state.
    ///
    /// It is recommended that the `observe` argument transform the store's state into the bare
    /// minimum of data needed for the feature to do its job in order to not hinder performance.
    /// This is especially true for root level features, and less important for leaf features.
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A transformation of `ViewState` to the state that will be observed for
    ///   changes.
    @MainActor public convenience init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: State) -> ViewState)

    /// Initializes a view store from a store which observes changes to state.
    ///
    /// It is recommended that the `observe` argument transform the store's state into the bare
    /// minimum of data needed for the feature to do its job in order to not hinder performance.
    /// This is especially true for root level features, and less important for leaf features.
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A transformation of `ViewState` to the state that will be observed for
    ///   changes.
    ///   - fromViewAction: A transformation of `ViewAction` that describes what actions can be sent.
    @MainActor public convenience init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: State) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action)
}

/// A convenience type alias for referring to a view store of a given reducer's domain.
///
/// Instead of specifying two generics:
///
/// ```swift
/// let viewStore: ViewStore<Feature.State, Feature.Action>
/// ```
///
/// You can specify a single generic:
///
/// ```swift
/// let viewStore: ViewStoreOf<Feature>
/// ```
public typealias ViewStoreOf<R> = ComposableArchitecture.ViewStore<R.State, R.Action> where R : ComposableArchitecture.Reducer

/// A view helper that transforms a ``Store`` into a ``ViewStore`` so that its state can be observed
/// by a view builder.
///
/// This helper is an alternative to observing the view store manually on your view, which requires
/// the boilerplate of a custom initializer.
///
/// > Important: It is important to properly leverage the `observe` argument in order to observe
/// only the state that your view needs to do its job. See the "Performance" section below for more
/// information.
///
/// For example, the following view, which manually observes the store it is handed by constructing
/// a view store in its initializer:
///
/// ```swift
/// struct ProfileView: View {
///   let store: StoreOf<Profile>
///   @ObservedObject var viewStore: ViewStoreOf<Profile>
///
///   init(store: StoreOf<Profile>) {
///     self.store = store
///     self.viewStore = ViewStore(store, observe: { $0 })
///   }
///
///   var body: some View {
///     Text("\(self.viewStore.username)")
///     // ...
///   }
/// }
/// ```
///
/// â€¦can be written more simply using `WithViewStore`:
///
/// ```swift
/// struct ProfileView: View {
///   let store: StoreOf<Profile>
///
///   var body: some View {
///     WithViewStore(self.store, observe: { $0 }) { viewStore in
///       Text("\(viewStore.username)")
///       // ...
///     }
///   }
/// }
/// ```
///
/// There may be times where the slightly more verbose style of observing a store is preferred
/// instead of using ``WithViewStore``:
///
///   1. When ``WithViewStore`` wraps complex views the Swift compiler can quickly become bogged
///      down, leading to degraded compiler performance and diagnostics. If you are experiencing
///      such instability you should consider manually setting up observation with an
///      `@ObservedObject` property as described above.
///
///   2. Sometimes you may want to observe the state in a store in a context that is not a view
///      builder. In such cases ``WithViewStore`` will not work since it is intended only for
///      SwiftUI views.
///
///      An example of this is interfacing with SwiftUI's `App` protocol, which uses a separate
///      `@SceneBuilder` instead of `@ViewBuilder`. In this case you must use an `@ObservedObject`:
///
///      ```swift
///      @main
///      struct MyApp: App {
///        let store = StoreOf<AppFeature>(/* ... */)
///        @ObservedObject var viewStore: ViewStore<SceneState, CommandAction>
///
///        struct SceneState: Equatable {
///          // ...
///          init(state: AppFeature.State) {
///            // ...
///          }
///        }
///
///        init() {
///          self.viewStore = ViewStore(
///            self.store.scope(
///              state: SceneState.init(state:)
///              action: AppFeature.Action.scene
///            )
///          )
///        }
///
///        var body: some Scene {
///          WindowGroup {
///            MyRootView()
///          }
///          .commands {
///            CommandMenu("Help") {
///              Button("About \(self.viewStore.appName)") {
///                self.viewStore.send(.aboutButtonTapped)
///              }
///            }
///          }
///        }
///      }
///      ```
///
///      Note that it is highly discouraged for you to observe _all_ of your root store's state.
///      It is almost never needed and will cause many view recomputations leading to poor
///      performance. This is why we construct a separate `SceneState` type that holds onto only the
///      state that the view needs for rendering. See <doc:Performance> for more information on this
///      topic.
///
/// If your view does not need access to any state in the store and only needs to be able to send
/// actions, then you should consider not using ``WithViewStore`` at all. Instead, you can send
/// actions directly to a ``Store`` like so:
///
/// ```swift
/// Button("Tap me") {
///   self.store.send(.buttonTapped)
/// }
/// ```
///
/// ## Performance
///
/// A common performance pitfall when using the library comes from constructing ``ViewStore``s and
/// ``WithViewStore``s. When constructed naively, using either view store's initializer
/// ``ViewStore/init(_:observe:)-3ak1y`` or the SwiftUI helper ``WithViewStore``, it  will observe
/// every change to state in the store:
///
/// ```swift
/// WithViewStore(self.store, observe: { $0 }) { viewStore in
///   // This is executed for every action sent into the system
///   // that causes self.store.state to change.
/// }
/// ```
///
/// Most of the time this observes far too much state. A typical feature in the Composable
/// Architecture holds onto not only the state the view needs to present UI, but also state that the
/// feature only needs internally, as well as state of child features embedded in the feature.
/// Changes to the internal and child state should not cause the view's body to re-compute since
/// that state is not needed in the view.
///
/// For example, if the root of our application was a tab view, then we could model that in state
/// as a struct that holds each tab's state as a property:
///
/// ```swift
/// @Reducer
/// struct AppFeature {
///   struct State {
///     var activity: Activity.State
///     var search: Search.State
///     var profile: Profile.State
///   }
///   // ...
/// }
/// ```
///
/// If the view only needs to construct the views for each tab, then no view store is even needed
/// because we can pass scoped stores to each child feature view:
///
/// ```swift
/// struct AppView: View {
///   let store: StoreOf<AppFeature>
///
///   var body: some View {
///     // No need to observe state changes because the view does
///     // not need access to the state.
///     TabView {
///       ActivityView(
///         store: self.store
///           .scope(state: \.activity, action: \.activity)
///       )
///       SearchView(
///         store: self.store
///           .scope(state: \.search, action: \.search)
///       )
///       ProfileView(
///         store: self.store
///           .scope(state: \.profile, action: \.profile)
///       )
///     }
///   }
/// }
/// ```
///
/// This means `AppView` does not actually need to observe any state changes. This view will only be
/// created a single time, whereas if we observed the store then it would re-compute every time a single
/// thing changed in either the activity, search or profile child features.
///
/// If sometime in the future we do actually need some state from the store, we can start to observe
/// only the bare essentials of state necessary for the view to do its job. For example, suppose that
/// we need access to the currently selected tab in state:
///
/// ```swift
/// @Reducer
/// struct AppFeature {
///   enum Tab { case activity, search, profile }
///   struct State {
///     var activity: Activity.State
///     var search: Search.State
///     var profile: Profile.State
///     var selectedTab: Tab
///   }
///   // ...
/// }
/// ```
///
/// Then we can observe this state so that we can construct a binding to `selectedTab` for the tab view:
///
/// ```swift
/// struct AppView: View {
///   let store: StoreOf<AppFeature>
///
///   var body: some View {
///     WithViewStore(self.store, observe: { $0 }) { viewStore in
///       TabView(
///         selection: viewStore.binding(get: \.selectedTab, send: { .tabSelected($0) })
///       ) {
///         ActivityView(
///           store: self.store.scope(state: \.activity, action: \.activity)
///         )
///         .tag(AppFeature.Tab.activity)
///         SearchView(
///           store: self.store.scope(state: \.search, action: \.search)
///         )
///         .tag(AppFeature.Tab.search)
///         ProfileView(
///           store: self.store.scope(state: \.profile, action: \.profile)
///         )
///         .tag(AppFeature.Tab.profile)
///       }
///     }
///   }
/// }
/// ```
///
/// However, this style of state observation is terribly inefficient since _every_ change to
/// `AppFeature.State` will cause the view to re-compute even though the only piece of state we
/// actually care about is the `selectedTab`. The reason we are observing too much state is because
/// we use `observe: { $0 }` in the construction of the ``WithViewStore``, which means the view
/// store will observe all of state.
///
/// To chisel away at the observed state you can provide a closure for that argument that plucks out
/// the state the view needs. In this case the view only needs a single field:
///
/// ```swift
/// WithViewStore(self.store, observe: \.selectedTab) { viewStore in
///   TabView(selection: viewStore.binding(send: { .tabSelected($0) }) {
///     // ...
///   }
/// }
/// ```
///
/// In the future, the view may need access to more state. For example, suppose `Activity.State`
/// holds onto an `unreadCount` integer to represent how many new activities you have. There's no
/// need to observe _all_ of `Activity.State` to get access to this one field. You can observe just
/// the one field.
///
/// Technically you can do this by mapping your state into a tuple, but because tuples are not
/// `Equatable` you will need to provide an explicit `removeDuplicates` argument:
///
/// ```swift
/// WithViewStore(
///   self.store,
///   observe: { (selectedTab: $0.selectedTab, unreadActivityCount: $0.activity.unreadCount) },
///   removeDuplicates: ==
/// ) { viewStore in
///   TabView(selection: viewStore.binding(get: \.selectedTab, send: { .tabSelected($0) }) {
///     ActivityView(
///       store: self.store.scope(state: \.activity, action: \.activity)
///     )
///     .tag(AppFeature.Tab.activity)
///     .badge("\(viewStore.unreadActivityCount)")
///
///     // ...
///   }
/// }
/// ```
///
/// Alternatively, and recommended, you can introduce a lightweight, equatable `ViewState` struct
/// nested inside your view whose purpose is to transform the `Store`'s full state into the bare
/// essentials of what the view needs:
///
/// ```swift
/// struct AppView: View {
///   let store: StoreOf<AppFeature>
///
///   struct ViewState: Equatable {
///     let selectedTab: AppFeature.Tab
///     let unreadActivityCount: Int
///     init(state: AppFeature.State) {
///       self.selectedTab = state.selectedTab
///       self.unreadActivityCount = state.activity.unreadCount
///     }
///   }
///
///   var body: some View {
///     WithViewStore(self.store, observe: ViewState.init) { viewStore in
///       TabView {
///         ActivityView(
///           store: self.store
///             .scope(state: \.activity, action: \.activity)
///         )
///         .badge("\(viewStore.unreadActivityCount)")
///
///         // ...
///       }
///     }
///   }
/// }
/// ```
///
/// This gives you maximum flexibility in the future for adding new fields to `ViewState` without
/// making your view convoluted.
///
/// This technique for reducing view re-computations is most effective towards the root of your app
/// hierarchy and least effective towards the leaf nodes of your app. Root features tend to hold
/// lots of state that its view does not need, such as child features, and leaf features tend to
/// only hold what's necessary. If you are going to employ this technique you will get the most
/// benefit by applying it to views closer to the root. At leaf features and views that need access
/// to most of the state, it is fine to continue using `observe: { $0 }` to observe all of the state
/// in the store.
@available(iOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@available(macOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@available(tvOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@available(watchOS, deprecated: 9999, message: "Use '@ObservableState', instead. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Using-ObservableState")
@MainActor public struct WithViewStore<ViewState, ViewAction, Content> : View where Content : View {

    /// Prints debug information to the console whenever the view is computed.
    ///
    /// - Parameter prefix: A string with which to prefix all debug messages.
    /// - Returns: A structure that prints debug messages for all computations.
    @MainActor public func _printChanges(_ prefix: String = "") -> ComposableArchitecture.WithViewStore<ViewState, ViewAction, Content>

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: Content { get }

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute views from state.
    ///
    /// ``WithViewStore`` will re-compute its body for _any_ change to the state it holds. Often the
    /// ``Store`` that we want to observe holds onto a lot more state than is necessary to render a
    /// view. It may hold onto the state of child features, or internal state for its logic.
    ///
    /// It can be important to transform the ``Store``'s state into something smaller for observation.
    /// This will help minimize the number of times your view re-computes its body, and can even avoid
    /// certain SwiftUI bugs that happen due to over-rendering.
    ///
    /// The way to do this is to use the `observe` argument of this initializer. It allows you to
    /// turn the full state into a smaller data type, and only changes to that data type will trigger
    /// a body re-computation.
    ///
    /// For example, if your application uses a tab view, then the root state may hold the state
    /// for each tab as well as the currently selected tab:
    ///
    /// ```swift
    /// @Reducer
    /// struct AppFeature {
    ///   enum Tab { case activity, search, profile }
    ///   struct State {
    ///     var activity: Activity.State
    ///     var search: Search.State
    ///     var profile: Profile.State
    ///     var selectedTab: Tab
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// In order to construct a tab view you need to observe this state because changes to
    /// `selectedTab` need to make SwiftUI update the visual state of the UI. However, you do not
    /// need to observe changes to `activity`, `search` and `profile`. Those are only necessary for
    /// those child features, and changes to that state should not cause our tab view to re-compute
    /// itself.
    ///
    /// ```swift
    /// struct AppView: View {
    ///   let store: StoreOf<AppFeature>
    ///
    ///   var body: some View {
    ///     WithViewStore(self.store, observe: \.selectedTab) { viewStore in
    ///       TabView(selection: viewStore.binding(send: { .tabSelected($0) }) {
    ///         ActivityView(
    ///           store: self.store.scope(state: \.activity, action: \.activity)
    ///         )
    ///         .tag(AppFeature.Tab.activity)
    ///         SearchView(
    ///           store: self.store.scope(state: \.search, action: \.search)
    ///         )
    ///         .tag(AppFeature.Tab.search)
    ///         ProfileView(
    ///           store: self.store.scope(state: \.profile, action: \.profile)
    ///         )
    ///         .tag(AppFeature.Tab.profile)
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms store state into observable view state. All
    ///   changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - fromViewAction: A function that transforms view actions into store action.
    ///   - isDuplicate: A function to determine when two `ViewState` values are equal. When values
    ///     are equal, repeat view computations are removed.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: State) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line)

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute views from state.
    ///
    /// ``WithViewStore`` will re-compute its body for _any_ change to the state it holds. Often the
    /// ``Store`` that we want to observe holds onto a lot more state than is necessary to render a
    /// view. It may hold onto the state of child features, or internal state for its logic.
    ///
    /// It can be important to transform the ``Store``'s state into something smaller for observation.
    /// This will help minimize the number of times your view re-computes its body, and can even avoid
    /// certain SwiftUI bugs that happen due to over-rendering.
    ///
    /// The way to do this is to use the `observe` argument of this initializer. It allows you to
    /// turn the full state into a smaller data type, and only changes to that data type will trigger
    /// a body re-computation.
    ///
    /// For example, if your application uses a tab view, then the root state may hold the state
    /// for each tab as well as the currently selected tab:
    ///
    /// ```swift
    /// @Reducer
    /// struct AppFeature {
    ///   enum Tab { case activity, search, profile }
    ///   struct State {
    ///     var activity: Activity.State
    ///     var search: Search.State
    ///     var profile: Profile.State
    ///     var selectedTab: Tab
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// In order to construct a tab view you need to observe this state because changes to
    /// `selectedTab` need to make SwiftUI update the visual state of the UI. However, you do not
    /// need to observe changes to `activity`, `search` and `profile`. Those are only necessary for
    /// those child features, and changes to that state should not cause our tab view to re-compute
    /// itself.
    ///
    /// ```swift
    /// struct AppView: View {
    ///   let store: StoreOf<AppFeature>
    ///
    ///   var body: some View {
    ///     WithViewStore(self.store, observe: \.selectedTab) { viewStore in
    ///       TabView(selection: viewStore.binding(send: { .tabSelected($0) }) {
    ///         ActivityView(
    ///           store: self.store.scope(state: \.activity, action: \.activity)
    ///         )
    ///         .tag(AppFeature.Tab.activity)
    ///         SearchView(
    ///           store: self.store.scope(state: \.search, action: \.search)
    ///         )
    ///         .tag(AppFeature.Tab.search)
    ///         ProfileView(
    ///           store: self.store.scope(state: \.profile, action: \.profile)
    ///         )
    ///         .tag(AppFeature.Tab.profile)
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms store state into observable view state. All
    ///   changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - isDuplicate: A function to determine when two `ViewState` values are equal. When values
    ///     are equal, repeat view computations are removed.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: State) -> ViewState, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line)
}

extension WithViewStore {

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings and views from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - fromViewAction: A function that transforms view actions into store action.
    ///   - isDuplicate: A function to determine when two `ViewState` values are equal. When values
    ///     are equal, repeat view computations are removed.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings and views from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - isDuplicate: A function to determine when two `ViewState` values are equal. When values
    ///     are equal, repeat view computations are removed.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, removeDuplicates isDuplicate: @escaping (_ lhs: ViewState, _ rhs: ViewState) -> Bool, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State
}

extension WithViewStore where ViewState : Equatable {

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings and views from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - fromViewAction: A function that transforms view actions into store action.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute bindings and views from state.
    ///
    /// Read <doc:Bindings> for more information.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms binding store state into observable view state.
    ///     All changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: ComposableArchitecture.BindingViewStore<State>) -> ViewState, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line) where ViewAction : ComposableArchitecture.BindableAction, State == ViewAction.State
}

extension WithViewStore where ViewState : Equatable {

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute views from state.
    ///
    /// ``WithViewStore`` will re-compute its body for _any_ change to the state it holds. Often the
    /// ``Store`` that we want to observe holds onto a lot more state than is necessary to render a
    /// view. It may hold onto the state of child features, or internal state for its logic.
    ///
    /// It can be important to transform the ``Store``'s state into something smaller for observation.
    /// This will help minimize the number of times your view re-computes its body, and can even avoid
    /// certain SwiftUI bugs that happen due to over-rendering.
    ///
    /// The way to do this is to use the `observe` argument of this initializer. It allows you to
    /// turn the full state into a smaller data type, and only changes to that data type will trigger
    /// a body re-computation.
    ///
    /// For example, if your application uses a tab view, then the root state may hold the state
    /// for each tab as well as the currently selected tab:
    ///
    /// ```swift
    /// @Reducer
    /// struct AppFeature {
    ///   enum Tab { case activity, search, profile }
    ///   struct State {
    ///     var activity: Activity.State
    ///     var search: Search.State
    ///     var profile: Profile.State
    ///     var selectedTab: Tab
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// In order to construct a tab view you need to observe this state because changes to
    /// `selectedTab` need to make SwiftUI update the visual state of the UI. However, you do not
    /// need to observe changes to `activity`, `search` and `profile`. Those are only necessary for
    /// those child features, and changes to that state should not cause our tab view to re-compute
    /// itself.
    ///
    /// ```swift
    /// struct AppView: View {
    ///   let store: StoreOf<AppFeature>
    ///
    ///   var body: some View {
    ///     WithViewStore(self.store, observe: \.selectedTab) { viewStore in
    ///       TabView(selection: viewStore.binding(send: { .tabSelected($0) }) {
    ///         ActivityView(
    ///           store: self.store.scope(state: \.activity, action: \.activity)
    ///         )
    ///         .tag(AppFeature.Tab.activity)
    ///         SearchView(
    ///           store: self.store.scope(state: \.search, action: \.search)
    ///         )
    ///         .tag(AppFeature.Tab.search)
    ///         ProfileView(
    ///           store: self.store.scope(state: \.profile, action: \.profile)
    ///         )
    ///         .tag(AppFeature.Tab.profile)
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms store state into observable view state. All
    ///   changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - fromViewAction: A function that transforms view actions into store action.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State, Action>(_ store: ComposableArchitecture.Store<State, Action>, observe toViewState: @escaping (_ state: State) -> ViewState, send fromViewAction: @escaping (_ viewAction: ViewAction) -> Action, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line)

    /// Initializes a structure that transforms a ``Store`` into an observable ``ViewStore`` in order
    /// to compute views from state.
    ///
    /// ``WithViewStore`` will re-compute its body for _any_ change to the state it holds. Often the
    /// ``Store`` that we want to observe holds onto a lot more state than is necessary to render a
    /// view. It may hold onto the state of child features, or internal state for its logic.
    ///
    /// It can be important to transform the ``Store``'s state into something smaller for observation.
    /// This will help minimize the number of times your view re-computes its body, and can even avoid
    /// certain SwiftUI bugs that happen due to over-rendering.
    ///
    /// The way to do this is to use the `observe` argument of this initializer. It allows you to
    /// turn the full state into a smaller data type, and only changes to that data type will trigger
    /// a body re-computation.
    ///
    /// For example, if your application uses a tab view, then the root state may hold the state
    /// for each tab as well as the currently selected tab:
    ///
    /// ```swift
    /// @Reducer
    /// struct AppFeature {
    ///   enum Tab { case activity, search, profile }
    ///   struct State {
    ///     var activity: Activity.State
    ///     var search: Search.State
    ///     var profile: Profile.State
    ///     var selectedTab: Tab
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// In order to construct a tab view you need to observe this state because changes to
    /// `selectedTab` need to make SwiftUI update the visual state of the UI. However, you do not
    /// need to observe changes to `activity`, `search` and `profile`. Those are only necessary for
    /// those child features, and changes to that state should not cause our tab view to re-compute
    /// itself.
    ///
    /// ```swift
    /// struct AppView: View {
    ///   let store: StoreOf<AppFeature>
    ///
    ///   var body: some View {
    ///     WithViewStore(self.store, observe: \.selectedTab) { viewStore in
    ///       TabView(selection: viewStore.binding(send: { .tabSelected($0) }) {
    ///         ActivityView(
    ///           store: self.store.scope(state: \.activity, action: \.activity)
    ///         )
    ///         .tag(AppFeature.Tab.activity)
    ///         SearchView(
    ///           store: self.store.scope(state: \.search, action: \.search)
    ///         )
    ///         .tag(AppFeature.Tab.search)
    ///         ProfileView(
    ///           store: self.store.scope(state: \.profile, action: \.profile)
    ///         )
    ///         .tag(AppFeature.Tab.profile)
    ///       }
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// To read more about this performance technique, read the <doc:Performance> article.
    ///
    /// - Parameters:
    ///   - store: A store.
    ///   - toViewState: A function that transforms store state into observable view state. All
    ///   changes to the view state will cause the `WithViewStore` to re-compute its view.
    ///   - content: A function that can generate content from a view store.
    ///   - file: The file.
    ///   - line: The line.
    @MainActor public init<State>(_ store: ComposableArchitecture.Store<State, ViewAction>, observe toViewState: @escaping (_ state: State) -> ViewState, @ViewBuilder content: @escaping (_ viewStore: ComposableArchitecture.ViewStore<ViewState, ViewAction>) -> Content, file: StaticString = #fileID, line: UInt = #line)
}

extension WithViewStore : @preconcurrency DynamicViewContent where ViewState : Collection, Content : DynamicViewContent {

    /// The type of the underlying collection of data.
    public typealias Data = ViewState

    /// The collection of underlying data.
    @MainActor public var data: ViewState { get }
}

@inlinable public func _$isIdentityEqual<T>(_ lhs: T, _ rhs: T) -> Bool where T : ComposableArchitecture.ObservableState

@inlinable public func _$isIdentityEqual<ID, T>(_ lhs: IdentifiedCollections.IdentifiedArray<ID, T>, _ rhs: IdentifiedCollections.IdentifiedArray<ID, T>) -> Bool where ID : Hashable, T : ComposableArchitecture.ObservableState

@inlinable public func _$isIdentityEqual<T>(_ lhs: ComposableArchitecture.PresentationState<T>, _ rhs: ComposableArchitecture.PresentationState<T>) -> Bool where T : ComposableArchitecture.ObservableState

@inlinable public func _$isIdentityEqual<T>(_ lhs: ComposableArchitecture.StackState<T>, _ rhs: ComposableArchitecture.StackState<T>) -> Bool where T : ComposableArchitecture.ObservableState

@inlinable public func _$isIdentityEqual<C>(_ lhs: C, _ rhs: C) -> Bool where C : Collection, C.Element : ComposableArchitecture.ObservableState

@inlinable public func _$isIdentityEqual(_ lhs: String, _ rhs: String) -> Bool

@inlinable public func _$isIdentityEqual<T>(_ lhs: T, _ rhs: T) -> Bool

@inlinable public func _$willModify<T>(_: inout T)

@inlinable public func _$willModify<T>(_ value: inout T) where T : ComposableArchitecture.ObservableState

public struct _CancelID : Hashable {
}

@MainActor public struct _CaseLetMismatchView<State, Action> : View {

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

public struct _DependencyKeyWritingReducer<Base> : ComposableArchitecture.Reducer where Base : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout Base.State, action: Base.Action) -> ComposableArchitecture.Effect<Base.Action>

    /// Sets the dependency value of the specified key path to the given value.
    ///
    /// This overrides the dependency specified by `keyPath` for the execution of the receiving
    /// reducer _and_ all of its effects. It can be useful for altering the dependencies for just
    /// one portion of your application, while letting the rest of the application continue using the
    /// default live dependencies.
    ///
    /// For example, suppose you are creating an onboarding experience to teach people how to use one
    /// of your features. This can be done by constructing a new reducer that embeds the core
    /// feature's domain and layers on additional logic:
    ///
    /// ```swift
    /// @Reducer
    /// struct Onboarding {
    ///   struct State {
    ///     var feature: Feature.State
    ///     // Additional onboarding state
    ///   }
    ///   enum Action {
    ///     case feature(Feature.Action)
    ///     // Additional onboarding actions
    ///   }
    ///
    ///   var body: some Reducer<State, Action> {
    ///     Scope(state: \.feature, action: \.feature) {
    ///       Feature()
    ///     }
    ///
    ///     Reduce { state, action in
    ///       // Additional onboarding logic
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// This can work just fine, but the `Feature` reducer will have access to all of the live
    /// dependencies by default, and that might not be ideal. For example, the `Feature` reducer
    /// may need to make API requests and read/write from user defaults. It may be preferable
    /// to run the `Feature` reducer in an alternative environment for onboarding purposes, such
    /// as an API client that returns some mock data or an in-memory user defaults so that the
    /// onboarding experience doesn't accidentally trample on shared data.
    ///
    /// This can be by using the ``dependency(_:_:)`` method to override those dependencies
    /// just for the `Feature` reducer and its effects:
    ///
    /// ```swift
    /// var body: some Reducer<State, Action> {
    ///   Scope(state: \.feature, action: \.feature) {
    ///     Feature()
    ///       .dependency(\.apiClient, .mock)
    ///       .dependency(\.userDefaults, .mock)
    ///   }
    ///
    ///   Reduce { state, action in
    ///     // Additional onboarding logic
    ///   }
    /// }
    /// ```
    ///
    /// See ``transformDependency(_:transform:)`` for a similar method that can inspect and modify the
    /// current dependency when overriding.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the `DependencyValues` structure to
    ///     update.
    ///   - value: The new value to set for the item specified by `keyPath`.
    /// - Returns: A reducer that has the given value set in its dependencies.
    @inlinable public func dependency<Value>(_ keyPath: WritableKeyPath<Dependencies.DependencyValues, Value>, _ value: Value) -> ComposableArchitecture._DependencyKeyWritingReducer<Base>

    /// Transform a reducer's dependency value at the specified key path with the given function.
    ///
    /// This is similar to ``dependency(_:_:)``, except it allows you to mutate a dependency value
    /// directly. This can be handy when you want to alter a dependency but still use its current
    /// value.
    ///
    /// For example, suppose you want to see when a particular endpoint of a dependency gets called
    /// in your application. You can override that endpoint to insert a breakpoint or print statement,
    /// but still call out to the original endpoint:
    ///
    /// ```swift
    ///   Feature()
    ///     .transformDependency(\.speechClient) { speechClient in
    ///       speechClient.requestAuthorization = {
    ///         print("requestAuthorization")
    ///         try await speechClient.requestAuthorization()
    ///       }
    ///     }
    /// ```
    ///
    /// You can also transform _all_ dependency values at once by using the `\.self` key path:
    ///
    /// ```swift
    /// Feature()
    ///   .transformDependency(\.self) { dependencyValues in
    ///     // Access to all dependencies in here
    ///   }
    /// ```
    ///
    /// > Warning: The trailing closure of ``transformDependency(_:transform:)`` is called for every
    /// action sent to the reducer, and so you can expect it to be called many times in an
    /// application's lifecycle. This means you should typically not create dependencies in the
    /// closure as that will cause a new dependency to be created everytime an action is sent.
    ///
    /// - Parameters:
    ///   - keyPath: A key path that indicates the property of the `DependencyValues` structure to
    ///     transform.
    ///   - transform: A closure that is handed a mutable instance of the value specified by the key
    ///     path.
    @inlinable public func transformDependency<V>(_ keyPath: WritableKeyPath<Dependencies.DependencyValues, V>, transform: @escaping (inout V) -> Void) -> ComposableArchitecture._DependencyKeyWritingReducer<Base>
}

public struct _EffectPublisher<Action> : Publisher {

    /// The kind of values published by this publisher.
    public typealias Output = Action

    /// The kind of errors this publisher might publish.
    ///
    /// Use `Never` if this `Publisher` does not publish errors.
    public typealias Failure = Never

    public init(_ effect: ComposableArchitecture.Effect<Action>)

    /// Attaches the specified subscriber to this publisher.
    ///
    /// Implementations of ``Publisher`` must implement this method.
    ///
    /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
    ///
    /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
    public func receive(subscriber: some Subscriber<Action, Never>)
}

/// Loosely represents features that are only briefly shown and the first time they are interacted
/// with they are dismissed. Such features do not manage any behavior on the inside.
///
/// Alerts and confirmation dialogs are examples of this kind of state.
public protocol _EphemeralState<Action> {

    associatedtype Action

    static var actionType: any Any.Type { get }
}

extension _EphemeralState {

    public static var actionType: any Any.Type { get }
}

public struct _ForEachReducer<Parent, ID, Element> : ComposableArchitecture.Reducer where Parent : ComposableArchitecture.Reducer, ID : Hashable, ID : Sendable, Element : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    public func reduce(into state: inout Parent.State, action: Parent.Action) -> ComposableArchitecture.Effect<Parent.Action>
}

public struct _HashableStaticString : RawRepresentable {

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public let rawValue: StaticString

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional(PaperSize.Legal)"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init(rawValue: StaticString)
}

extension _HashableStaticString : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: StaticString)
}

extension _HashableStaticString : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

extension _HashableStaticString : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

extension _HashableStaticString : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: ComposableArchitecture._HashableStaticString, rhs: ComposableArchitecture._HashableStaticString) -> Bool
}

extension _HashableStaticString : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

public struct _IfCaseLetReducer<Parent, Child> : ComposableArchitecture.Reducer where Parent : ComposableArchitecture.Reducer, Child : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    public func reduce(into state: inout Parent.State, action: Parent.Action) -> ComposableArchitecture.Effect<Parent.Action>
}

public struct _IfLetReducer<Parent, Child> : ComposableArchitecture.Reducer where Parent : ComposableArchitecture.Reducer, Child : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    public func reduce(into state: inout Parent.State, action: Parent.Action) -> ComposableArchitecture.Effect<Parent.Action>
}

@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
@MainActor public struct _NavigationDestinationViewModifier<State, Action, Destination> : ViewModifier where State : ComposableArchitecture.ObservableState, Destination : View {

    /// Gets the current body of the caller.
    ///
    /// `content` is a proxy for the view that will have the modifier
    /// represented by `Self` applied to it.
    @MainActor public func body(content: ComposableArchitecture._NavigationDestinationViewModifier<State, Action, Destination>.Content) -> some View

}

@MainActor public struct _NavigationLinkStoreContent<State, Label> : View where Label : View {

    @MainActor public init(state: State?, @ViewBuilder label: () -> Label, fileID: StaticString, filePath: StaticString, line: UInt, column: UInt)

    /// The content and behavior of the view.
    ///
    /// When you implement a custom view, you must implement a computed
    /// `body` property to provide the content for your view. Return a view
    /// that's composed of built-in views that SwiftUI provides, plus other
    /// composite views that you've already defined:
    ///
    ///     struct MyView: View {
    ///         var body: some View {
    ///             Text("Hello, World!")
    ///         }
    ///     }
    ///
    /// For more information about composing views and a view hierarchy,
    /// see <doc:Declaring-a-Custom-View>.
    @MainActor public var body: some View { get }
}

public struct _OnChangeReducer<Base, Value, Body> : ComposableArchitecture.Reducer where Base : ComposableArchitecture.Reducer, Body : ComposableArchitecture.Reducer, Base.Action == Body.Action, Base.State == Body.State {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout Base.State, action: Base.Action) -> ComposableArchitecture.Effect<Base.Action>
}

public struct _PresentationReducer<Base, Destination> : ComposableArchitecture.Reducer where Base : ComposableArchitecture.Reducer, Destination : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    public func reduce(into state: inout Base.State, action: Base.Action) -> ComposableArchitecture.Effect<Base.Action>
}

public struct _PresentedID : Hashable, Sendable {

    @inlinable public init()
}

public struct _PrintChangesReducer<Base> : ComposableArchitecture.Reducer where Base : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    public func reduce(into state: inout Base.State, action: Base.Action) -> ComposableArchitecture.Effect<Base.Action>
}

extension _PrintChangesReducer : Sendable where Base : Sendable {
}

public struct _ReducerPrinter<State, Action> : Sendable {

    public init(printChange: @escaping @Sendable (_ receivedAction: Action, _ oldState: State, _ newState: State) -> Void, queue: DispatchQueue? = nil)

    public func printChange(receivedAction: Action, oldState: State, newState: State)
}

extension _ReducerPrinter {

    public static var customDump: ComposableArchitecture._ReducerPrinter<State, Action> { get }

    public static var actionLabels: ComposableArchitecture._ReducerPrinter<State, Action> { get }
}

public typealias _SendableAnyKeyPath = any AnyKeyPath & Sendable

public typealias _SendableCaseKeyPath<Root, Value> = any CasePathsCore.CaseKeyPath<Root, Value> & Sendable

public typealias _SendableKeyPath<Root, Value> = any KeyPath<Root, Value> & Sendable

public typealias _SendablePartialCaseKeyPath<Root> = any CasePathsCore.PartialCaseKeyPath<Root> & Sendable

public typealias _SendablePartialKeyPath<Root> = any PartialKeyPath<Root> & Sendable

public typealias _SendableReferenceWritableKeyPath<Root, Value> = any ReferenceWritableKeyPath<Root, Value> & Sendable

public typealias _SendableWritableKeyPath<Root, Value> = any WritableKeyPath<Root, Value> & Sendable

public struct _SignpostReducer<Base> : ComposableArchitecture.Reducer where Base : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout Base.State, action: Base.Action) -> ComposableArchitecture.Effect<Base.Action>
}

public struct _StackReducer<Base, Destination> : ComposableArchitecture.Reducer where Base : ComposableArchitecture.Reducer, Destination : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    public func reduce(into state: inout Base.State, action: Base.Action) -> ComposableArchitecture.Effect<Base.Action>
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
@dynamicMemberLookup public struct _StoreBindable_SwiftUI<State, Action, Value> where State : ComposableArchitecture.ObservableState {

    public subscript<Member>(dynamicMember keyPath: KeyPath<Value, Member>) -> ComposableArchitecture._StoreBindable_SwiftUI<State, Action, Member> { get }

    /// Creates a binding to the value by sending new values through the given action.
    ///
    /// - Parameter action: An action for the binding to send values through.
    /// - Returns: A binding.
    @MainActor @preconcurrency public func sending(_ action: CasePathsCore.CaseKeyPath<Action, Value>) -> Binding<Value>
}

@dynamicMemberLookup public struct _StoreBinding<State, Action, Value> where State : ComposableArchitecture.ObservableState {

    public subscript<Member>(dynamicMember keyPath: KeyPath<Value, Member>) -> ComposableArchitecture._StoreBinding<State, Action, Member> { get }

    /// Creates a binding to the value by sending new values through the given action.
    ///
    /// - Parameter action: An action for the binding to send values through.
    /// - Returns: A binding.
    @MainActor @preconcurrency public func sending(_ action: CasePathsCore.CaseKeyPath<Action, Value>) -> Binding<Value>
}

public struct _StoreCollection<ID, State, Action> : RandomAccessCollection where ID : Hashable, ID : Sendable {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: Int { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: Int) -> ComposableArchitecture.Store<State, Action> { get }
}

@dynamicMemberLookup public struct _StoreObservedObject<State, Action, Value> where State : ComposableArchitecture.ObservableState {

    public subscript<Member>(dynamicMember keyPath: KeyPath<Value, Member>) -> ComposableArchitecture._StoreObservedObject<State, Action, Member> { get }

    /// Creates a binding to the value by sending new values through the given action.
    ///
    /// - Parameter action: An action for the binding to send values through.
    /// - Returns: A binding.
    @MainActor @preconcurrency public func sending(_ action: CasePathsCore.CaseKeyPath<Action, Value>) -> Binding<Value>
}

public struct _StoreUIBindable<State, Action, Value> where State : ComposableArchitecture.ObservableState {

    public subscript<Member>(dynamicMember keyPath: KeyPath<Value, Member>) -> ComposableArchitecture._StoreUIBindable<State, Action, Member> { get }

    /// Creates a binding to the value by sending new values through the given action.
    ///
    /// - Parameter action: An action for the binding to send values through.
    /// - Returns: A binding.
    @MainActor public func sending(_ action: CasePathsCore.CaseKeyPath<Action, Value>) -> SwiftNavigation.UIBinding<Value>
}

@dynamicMemberLookup public struct _StoreUIBinding<State, Action, Value> where State : ComposableArchitecture.ObservableState {

    public subscript<Member>(dynamicMember keyPath: KeyPath<Value, Member>) -> ComposableArchitecture._StoreUIBinding<State, Action, Member> { get }

    /// Creates a binding to the value by sending new values through the given action.
    ///
    /// - Parameter action: An action for the binding to send values through.
    /// - Returns: A binding.
    @MainActor public func sending(_ action: CasePathsCore.CaseKeyPath<Action, Value>) -> SwiftNavigation.UIBinding<Value>
}

/// A description of a protocol conformance to synthesize on the State and Action types generated by
/// the ``Reducer()`` macro.
///
/// See <doc:Reducers#Synthesizing-protocol-conformances-on-State-and-Action> for more information.
@available(*, deprecated, message: "Define your conformance using an extension, instead")
public struct _SynthesizedConformance : Sendable {
}

@available(*, deprecated, message: "Define your conformance using an extension, instead")
extension _SynthesizedConformance {

    /// Extends the `State` or `Action` types that ``Reducer()`` creates with the `Codable`
    /// protocol.
    public static let codable: ComposableArchitecture._SynthesizedConformance

    /// Extends the `State` or `Action` types that ``Reducer()`` creates with the `Decodable`
    /// protocol.
    public static let decodable: ComposableArchitecture._SynthesizedConformance

    /// Extends the `State` or `Action` types that ``Reducer()`` creates with the `Encodable`
    /// protocol.
    public static let encodable: ComposableArchitecture._SynthesizedConformance

    /// Extends the `State` or `Action` types that ``Reducer()`` creates with the `Equatable`
    /// protocol.
    public static let equatable: ComposableArchitecture._SynthesizedConformance

    /// Extends the `State` or `Action` types that ``Reducer()`` creates with the `Hashable`
    /// protocol.
    public static let hashable: ComposableArchitecture._SynthesizedConformance

    /// Extends the `State` or `Action` types that ``Reducer()`` creates with the `Sendable`
    /// protocol.
    public static let sendable: ComposableArchitecture._SynthesizedConformance
}

public let _cancellationCancellables: ConcurrencyExtras.LockIsolated<ComposableArchitecture.CancellablesCollection>

public var _isInPerceptionTracking: Bool { get }

public let willEnterForegroundNotificationName: Notification.Name?

public var willResignNotificationName: Notification.Name? { get }

public let willTerminateNotificationName: Notification.Name?

/// Execute an operation with a cancellation identifier.
///
/// If the operation is in-flight when `Task.cancel(id:)` is called with the same identifier, the
/// operation will be cancelled.
///
/// ```swift
/// enum CancelID { case timer }
///
/// await withTaskCancellation(id: CancelID.timer) {
///   // Start cancellable timer...
/// }
/// ```
///
/// ### Debouncing tasks
///
/// When paired with a clock, this function can be used to debounce a unit of async work by
/// specifying the `cancelInFlight`, which will automatically cancel any in-flight work with the
/// same identifier:
///
/// ```swift
/// @Dependency(\.continuousClock) var clock
/// enum CancelID { case response }
///
/// // ...
///
/// return .run { send in
///   try await withTaskCancellation(id: CancelID.response, cancelInFlight: true) {
///     try await self.clock.sleep(for: .seconds(0.3))
///     await send(
///       .debouncedResponse(await Result { try await environment.request() })
///     )
///   }
/// }
/// ```
///
/// - Parameters:
///   - id: A unique identifier for the operation.
///   - cancelInFlight: Determines if any in-flight operation with the same identifier should be
///     canceled before starting this new one.
///   - isolation: The isolation of the operation.
///   - operation: An async operation.
/// - Throws: An error thrown by the operation.
/// - Returns: A value produced by operation.
public func withTaskCancellation<T>(id: some Hashable & Sendable, cancelInFlight: Bool = false, isolation: isolated (any Actor)? = #isolation, operation: @escaping @Sendable () async throws -> T) async rethrows -> T where T : Sendable

extension DependencyValues {

    /// An effect that dismisses the current presentation.
    ///
    /// See the documentation of ``DismissEffect`` for more information.
    public var dismiss: ComposableArchitecture.DismissEffect
}

extension DependencyValues {

    /// A Boolean value that indicates whether the current feature is being presented from a parent
    /// feature.
    ///
    /// This value is set to true on reducers that are run from within
    /// ``Reducer/ifLet(_:action:destination:fileID:filePath:line:column:)-4ub6q`` and
    /// ``Reducer/forEach(_:action:destination:fileID:filePath:line:column:)-9svqb``.
    ///
    /// See ``DismissEffect`` for more information on how child features can easily dismiss themselves
    /// without communicating to the parent.
    public var isPresented: Bool { get }
}

extension Task where Success == Never, Failure == Never {

    /// Cancel any currently in-flight operation with the given identifier.
    ///
    /// - Parameter id: An identifier.
    public static func cancel(id: some Hashable & Sendable)
}

extension Result where Success : Sendable, Failure == any Error {

    /// Transforms a `TaskResult` into a `Result`.
    ///
    /// - Parameter result: A task result.
    @inlinable public init(_ result: ComposableArchitecture.TaskResult<Success>)
}

extension UIAlertController {

    @available(iOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @available(macOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @available(tvOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @available(watchOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @MainActor public convenience init<Action>(store: ComposableArchitecture.Store<SwiftNavigation.AlertState<Action>, ComposableArchitecture.PresentationAction<Action>>)

    @available(iOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @available(macOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @available(tvOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @available(watchOS, deprecated: 9999, message: "Use '@ObservableState' and the 'scope' operation on bindable stores. See the following migration guide for more information: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.13")
    @MainActor public convenience init<Action>(store: ComposableArchitecture.Store<SwiftNavigation.ConfirmationDialogState<Action>, ComposableArchitecture.PresentationAction<Action>>)
}

extension Binding {

    @available(*, deprecated, message: "Use 'Binding.init(_:)' to project an optional binding to a Boolean, instead.")
    public func isPresent<Wrapped>() -> Binding<Bool> where Value == Wrapped?
}

extension AlertState : ComposableArchitecture._EphemeralState {
}

@available(iOS 13, macOS 12, tvOS 13, watchOS 6, *)
extension ConfirmationDialogState : ComposableArchitecture._EphemeralState {
}

extension NSRecursiveLock {

    @discardableResult
    @inlinable public func sync<R>(work: () -> R) -> R
}

extension NSNotification.Name {

    @available(*, deprecated, renamed: "_runtimeWarning")
    public static let runtimeWarning: NSNotification.Name

    /// A notification that is posted when a runtime warning is emitted.
    public static let _runtimeWarning: NSNotification.Name
}

extension DependencyValues {

    public var stackElementID: ComposableArchitecture.StackElementIDGenerator
}

@available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
extension View {

    /// Presents an alert when a piece of optional state held in a store becomes non-`nil`.
    @MainActor @preconcurrency public func alert<Action>(_ item: Binding<ComposableArchitecture.Store<SwiftNavigation.AlertState<Action>, Action>?>) -> some View


    /// Presents an alert when a piece of optional state held in a store becomes non-`nil`.
    @MainActor @preconcurrency public func confirmationDialog<Action>(_ item: Binding<ComposableArchitecture.Store<SwiftNavigation.ConfirmationDialogState<Action>, Action>?>) -> some View

}

extension Binding {

    public subscript<State, Action, Member>(dynamicMember keyPath: KeyPath<State, Member>) -> ComposableArchitecture._StoreBinding<State, Action, Member> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState { get }
}

extension ObservedObject.Wrapper {

    @MainActor public subscript<State, Action, Member>(dynamicMember keyPath: KeyPath<State, Member>) -> ComposableArchitecture._StoreObservedObject<State, Action, Member> where ObjectType == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState { get }
}

extension UIBinding {

    public subscript<State, Action, Member>(dynamicMember keyPath: KeyPath<State, Member>) -> ComposableArchitecture._StoreUIBinding<State, Action, Member> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState { get }
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
extension Bindable {

    public subscript<State, Action, Member>(dynamicMember keyPath: KeyPath<State, Member>) -> ComposableArchitecture._StoreBindable_SwiftUI<State, Action, Member> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState { get }
}

extension UIBindable {

    public subscript<State, Action, Member>(dynamicMember keyPath: KeyPath<State, Member>) -> ComposableArchitecture._StoreUIBindable<State, Action, Member> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState { get }
}

extension Binding {

    /// Derives a binding to a store focused on ``StackState`` and ``StackAction``.
    ///
    /// This operator is most used in conjunction with `NavigationStack`, and in particular
    /// the initializer ``SwiftUI/NavigationStack/init(path:root:destination:fileID:filePath:line:column:)`` that
    /// ships with this library.
    ///
    /// For example, suppose you have a feature that holds onto ``StackState`` in its state in order
    /// to represent all the screens that can be pushed onto a navigation stack:
    ///
    /// ```swift
    /// @Reducer
    /// struct Feature {
    ///   @ObservableState
    ///   struct State {
    ///     var path: StackState<Path.State> = []
    ///   }
    ///   enum Action {
    ///     case path(StackActionOf<Path>)
    ///   }
    ///   var body: some ReducerOf<Self> {
    ///     Reduce { state, action in
    ///       // Core feature logic
    ///     }
    ///     .forEach(\.rows, action: \.rows) {
    ///       Child()
    ///     }
    ///   }
    ///   @Reducer
    ///   enum Path {
    ///     // ...
    ///   }
    /// }
    /// ```
    ///
    /// > Note: We are using the ``Reducer()`` macro on an enum to compose together all the features
    /// that can be pushed onto the stack. See <doc:Reducer#Destination-and-path-reducers> for
    /// more information.
    ///
    /// Then in the view you can use this operator, with
    /// `NavigationStack` ``SwiftUI/NavigationStack/init(path:root:destination:fileID:filePath:line:column:)``, to
    /// derive a store for each element in the stack:
    ///
    /// ```swift
    /// struct FeatureView: View {
    ///   @Bindable var store: StoreOf<Feature>
    ///
    ///   var body: some View {
    ///     NavigationStack(path: $store.scope(state: \.path, action: \.path)) {
    ///       // Root view
    ///     } destination: {
    ///       // Destinations
    ///     }
    ///   }
    /// }
    /// ```
    @MainActor @preconcurrency public func scope<State, Action, ElementState, ElementAction>(state: KeyPath<State, ComposableArchitecture.StackState<ElementState>>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.StackAction<ElementState, ElementAction>>) -> Binding<ComposableArchitecture.Store<ComposableArchitecture.StackState<ElementState>, ComposableArchitecture.StackAction<ElementState, ElementAction>>> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

extension ObservedObject.Wrapper {

    @MainActor @preconcurrency public func scope<State, Action, ElementState, ElementAction>(state: KeyPath<State, ComposableArchitecture.StackState<ElementState>>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.StackAction<ElementState, ElementAction>>) -> Binding<ComposableArchitecture.Store<ComposableArchitecture.StackState<ElementState>, ComposableArchitecture.StackAction<ElementState, ElementAction>>> where ObjectType == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
extension Bindable {

    /// Derives a binding to a store focused on ``StackState`` and ``StackAction``.
    ///
    /// See ``SwiftUI/Binding/scope(state:action:fileID:filePath:line:column:)`` defined on `Binding` for more
    /// information.
    @MainActor @preconcurrency public func scope<State, Action, ElementState, ElementAction>(state: KeyPath<State, ComposableArchitecture.StackState<ElementState>>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.StackAction<ElementState, ElementAction>>) -> Binding<ComposableArchitecture.Store<ComposableArchitecture.StackState<ElementState>, ComposableArchitecture.StackAction<ElementState, ElementAction>>> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

extension UIBindable {

    /// Derives a binding to a store focused on ``StackState`` and ``StackAction``.
    ///
    /// See ``SwiftUI/Binding/scope(state:action:fileID:filePath:line:column:)`` defined on `Binding` for more
    /// information.
    @MainActor @preconcurrency public func scope<State, Action, ElementState, ElementAction>(state: KeyPath<State, ComposableArchitecture.StackState<ElementState>>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.StackAction<ElementState, ElementAction>>) -> SwiftNavigation.UIBinding<ComposableArchitecture.Store<ComposableArchitecture.StackState<ElementState>, ComposableArchitecture.StackAction<ElementState, ElementAction>>> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
extension NavigationStack {

    /// Drives a navigation stack with a store.
    ///
    /// See the dedicated article on <doc:Navigation> for more information on the library's
    /// navigation tools, and in particular see <doc:StackBasedNavigation> for information on using
    /// this view.
    @MainActor public init<State, Action, Destination, R>(path: Binding<ComposableArchitecture.Store<ComposableArchitecture.StackState<State>, ComposableArchitecture.StackAction<State, Action>>>, @ViewBuilder root: () -> R, @ViewBuilder destination: @escaping (ComposableArchitecture.Store<State, Action>) -> Destination, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) where Data == ComposableArchitecture.StackState<State>.PathView, Root == ModifiedContent<R, ComposableArchitecture._NavigationDestinationViewModifier<State, Action, Destination>>, State : ComposableArchitecture.ObservableState, Destination : View, R : View
}

@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
extension NavigationLink where Destination == Never {

    /// Creates a navigation link that presents the view corresponding to an element of
    /// ``StackState``.
    ///
    /// When someone activates the navigation link that this initializer creates, SwiftUI looks for
    /// a parent `NavigationStack` view with a store of ``StackState`` containing elements that
    /// matches the type of this initializer's `state` input.
    ///
    /// See SwiftUI's documentation for `NavigationLink.init(value:label:)` for more.
    ///
    /// - Parameters:
    ///   - state: An optional value to present. When the user selects the link, SwiftUI stores a
    ///     copy of the value. Pass a `nil` value to disable the link.
    ///   - label: A label that describes the view that this link presents.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    @MainActor public init<P, L>(state: P?, @ViewBuilder label: () -> L, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) where Label == ComposableArchitecture._NavigationLinkStoreContent<P, L>, L : View

    /// Creates a navigation link that presents the view corresponding to an element of
    /// ``StackState``, with a text label that the link generates from a localized string key.
    ///
    /// When someone activates the navigation link that this initializer creates, SwiftUI looks for
    /// a parent ``NavigationStackStore`` view with a store of ``StackState`` containing elements
    /// that matches the type of this initializer's `state` input.
    ///
    /// See SwiftUI's documentation for `NavigationLink.init(_:value:)` for more.
    ///
    /// - Parameters:
    ///   - titleKey: A localized string that describes the view that this link
    ///     presents.
    ///   - state: An optional value to present. When the user selects the link, SwiftUI stores a
    ///     copy of the value. Pass a `nil` value to disable the link.
    ///   - fileID: The fileID.
    ///   - line: The line.
    @MainActor public init<P>(_ titleKey: LocalizedStringKey, state: P?, fileID: StaticString = #fileID, line: UInt = #line) where Label == ComposableArchitecture._NavigationLinkStoreContent<P, Text>

    /// Creates a navigation link that presents the view corresponding to an element of
    /// ``StackState``, with a text label that the link generates from a title string.
    ///
    /// When someone activates the navigation link that this initializer creates, SwiftUI looks for
    /// a parent ``NavigationStackStore`` view with a store of ``StackState`` containing elements
    /// that matches the type of this initializer's `state` input.
    ///
    /// See SwiftUI's documentation for `NavigationLink.init(_:value:)` for more.
    ///
    /// - Parameters:
    ///   - title: A string that describes the view that this link presents.
    ///   - state: An optional value to present. When the user selects the link, SwiftUI stores a
    ///     copy of the value. Pass a `nil` value to disable the link.
    ///   - fileID: The fileID.
    ///   - line: The line.
    @MainActor public init<S, P>(_ title: S, state: P?, fileID: StaticString = #fileID, line: UInt = #line) where Label == ComposableArchitecture._NavigationLinkStoreContent<P, Text>, S : StringProtocol
}

extension EnvironmentValues {

    public var navigationDestinationType: (any Any.Type)?
}

extension Binding {

    /// Scopes the binding of a store to a binding of an optional presentation store.
    ///
    /// Use this operator to derive a binding that can be handed to SwiftUI's various navigation
    /// view modifiers, such as `sheet(item:)`, `popover(item:)`, etc.
    ///
    ///
    /// For example, suppose your feature can present a child feature in a sheet. Then your feature's
    /// domain would hold onto the child's domain using the library's presentation tools (see
    /// <doc:TreeBasedNavigation> for more information on these tools):
    ///
    /// ```swift
    /// @Reducer
    /// struct Feature {
    ///   @ObservableState
    ///   struct State {
    ///     @Presents var child: Child.State?
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case child(PresentationActionOf<Child>)
    ///     // ...
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// Then you can derive a binding to the child domain that can be handed to the `sheet(item:)`
    /// view modifier:
    ///
    /// ```swift
    /// struct FeatureView: View {
    ///   @Bindable var store: StoreOf<Feature>
    ///
    ///   var body: some View {
    ///     // ...
    ///     .sheet(item: $store.scope(state: \.child, action: \.child)) { store in
    ///       ChildView(store: store)
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - state: A key path to optional child state.
    ///   - action: A case key path to presentation child actions.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A binding of an optional child store.
    @MainActor @preconcurrency public func scope<State, Action, ChildState, ChildAction>(state: KeyPath<State, ChildState?>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.PresentationAction<ChildAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> Binding<ComposableArchitecture.Store<ChildState, ChildAction>?> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

extension ObservedObject.Wrapper {

    @MainActor @preconcurrency public func scope<State, Action, ChildState, ChildAction>(state: KeyPath<State, ChildState?>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.PresentationAction<ChildAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> Binding<ComposableArchitecture.Store<ChildState, ChildAction>?> where ObjectType == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
extension Bindable {

    /// Scopes the binding of a store to a binding of an optional presentation store.
    ///
    /// Use this operator to derive a binding that can be handed to SwiftUI's various navigation
    /// view modifiers, such as `sheet(item:)`, `popover(item:)`, etc.
    ///
    ///
    /// For example, suppose your feature can present a child feature in a sheet. Then your
    /// feature's domain would hold onto the child's domain using the library's presentation tools
    /// (see <doc:TreeBasedNavigation> for more information on these tools):
    ///
    /// ```swift
    /// @Reducer
    /// struct Feature {
    ///   @ObservableState
    ///   struct State {
    ///     @Presents var child: Child.State?
    ///     // ...
    ///   }
    ///   enum Action {
    ///     case child(PresentationActionOf<Child>)
    ///     // ...
    ///   }
    ///   // ...
    /// }
    /// ```
    ///
    /// Then you can derive a binding to the child domain that can be handed to the `sheet(item:)`
    /// view modifier:
    ///
    /// ```swift
    /// struct FeatureView: View {
    ///   @Bindable var store: StoreOf<Feature>
    ///
    ///   var body: some View {
    ///     // ...
    ///     .sheet(item: $store.scope(state: \.child, action: \.child)) { store in
    ///       ChildView(store: store)
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// - Parameters:
    ///   - state: A key path to optional child state.
    ///   - action: A case key path to presentation child actions.
    ///   - fileID: The fileID.
    ///   - filePath: The filePath.
    ///   - line: The line.
    ///   - column: The column.
    /// - Returns: A binding of an optional child store.
    @MainActor @preconcurrency public func scope<State, Action, ChildState, ChildAction>(state: KeyPath<State, ChildState?>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.PresentationAction<ChildAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> Binding<ComposableArchitecture.Store<ChildState, ChildAction>?> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

extension UIBindable {

    @MainActor @preconcurrency public func scope<State, Action, ChildState, ChildAction>(state: KeyPath<State, ChildState?>, action: CasePathsCore.CaseKeyPath<Action, ComposableArchitecture.PresentationAction<ChildAction>>, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column) -> SwiftNavigation.UIBinding<ComposableArchitecture.Store<ChildState, ChildAction>?> where Value == ComposableArchitecture.Store<State, Action>, State : ComposableArchitecture.ObservableState
}

extension Optional : ComposableArchitecture.Reducer where Wrapped : ComposableArchitecture.Reducer {

    /// Evolves the current state of the reducer to the next state.
    ///
    /// Implement this requirement for "primitive" reducers, or reducers that work on leaf node
    /// features. To define a reducer by combining the logic of other reducers together, implement the
    /// ``body-swift.property`` requirement instead.
    ///
    /// - Parameters:
    ///   - state: The current state of the reducer.
    ///   - action: An action that can cause the state of the reducer to change, and/or kick off a
    ///     side effect that can communicate with the outside world.
    /// - Returns: An effect that can communicate with the outside world and feed actions back into
    ///   the system.
    @inlinable public func reduce(into state: inout Wrapped.State, action: Wrapped.Action) -> ComposableArchitecture.Effect<Wrapped.Action>
}

extension SharedReaderKey {

    /// Creates a persistence key for sharing data in user defaults given a key path.
    ///
    /// For example, one could initialize a key with the date and time at which the application was
    /// most recently launched, and access this date from anywhere using the `@Shared` property
    /// wrapper:
    ///
    /// ```swift
    /// @Shared(.appStorage(\.appLaunchedAt)) var appLaunchedAt = Date()
    /// ```
    ///
    /// - Parameter keyPath: A string key identifying a value to share in memory.
    /// - Returns: A persistence key.
    @available(*, deprecated, message: "Use 'appStorage' with a supported data type, instead")
    public static func appStorage<Value>(_ keyPath: ComposableArchitecture._SendableReferenceWritableKeyPath<UserDefaults, Value>) -> Self where Self == ComposableArchitecture.AppStorageKeyPathKey<Value>, Value : Sendable
}

@available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
extension View {

    /// Displays an alert when the store's state becomes non-`nil`, and dismisses it when it becomes
    /// `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for an
    ///     alert.
    @MainActor @preconcurrency public func alert<ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<SwiftNavigation.AlertState<ButtonAction>>, ComposableArchitecture.PresentationAction<ButtonAction>>) -> some View


    /// Displays an alert when the store's state becomes non-`nil`, and dismisses it when it becomes
    /// `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for an
    ///     alert.
    ///   - toDestinationState: A transformation to extract alert state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed alert actions into the presentation
    ///     action.
    @available(iOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public func alert<State, Action, ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> SwiftNavigation.AlertState<ButtonAction>?, action fromDestinationAction: @escaping (_ alertAction: ButtonAction) -> Action) -> some View

}

@available(iOS 15, macOS 12, tvOS 15, watchOS 8, *)
extension View {

    /// Displays a dialog when the store's state becomes non-`nil`, and dismisses it when it becomes
    /// `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for a
    ///     dialog.
    @MainActor @preconcurrency public func confirmationDialog<ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<SwiftNavigation.ConfirmationDialogState<ButtonAction>>, ComposableArchitecture.PresentationAction<ButtonAction>>) -> some View


    /// Displays a dialog when then store's state becomes non-`nil`, and dismisses it when it becomes
    /// `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for a
    ///     dialog.
    ///   - toDestinationState: A transformation to extract dialog state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed dialog actions into the presentation
    ///     action.
    @available(iOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public func confirmationDialog<State, Action, ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> SwiftNavigation.ConfirmationDialogState<ButtonAction>?, action fromDestinationAction: @escaping (_ confirmationDialogAction: ButtonAction) -> Action) -> some View

}

extension View {

    /// Displays an action sheet when the store's state becomes non-`nil`, and dismisses it when it
    /// becomes `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for an
    ///     alert.
    ///   - toDestinationState: A transformation to extract alert state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed alert actions into the presentation
    ///     action.
    @available(iOS, introduced: 13, deprecated: 100000, message: "use 'View.confirmationDialog(store:)' instead.")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13, deprecated: 100000, message: "use 'View.confirmationDialog(store:)' instead.")
    @available(watchOS, introduced: 6, deprecated: 100000, message: "use 'View.confirmationDialog(store:)' instead.")
    @MainActor @preconcurrency public func actionSheet<ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<SwiftNavigation.ConfirmationDialogState<ButtonAction>>, ComposableArchitecture.PresentationAction<ButtonAction>>) -> some View


    /// Displays an alert when the store's state becomes non-`nil`, and dismisses it when it becomes
    /// `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for an
    ///     alert.
    ///   - toDestinationState: A transformation to extract alert state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed alert actions into the presentation
    ///     action.
    @available(iOS, introduced: 13, deprecated: 100000, message: "use 'View.confirmationDialog(store:state:action:)' instead.")
    @available(macOS, unavailable)
    @available(tvOS, introduced: 13, deprecated: 100000, message: "use 'View.confirmationDialog(store:state:action:)' instead.")
    @available(watchOS, introduced: 6, deprecated: 100000, message: "use 'View.confirmationDialog(store:state:action:)' instead.")
    @MainActor @preconcurrency public func actionSheet<State, Action, ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> SwiftNavigation.ConfirmationDialogState<ButtonAction>?, action fromDestinationAction: @escaping (_ alertAction: ButtonAction) -> Action) -> some View

}

extension View {

    /// Displays a legacy alert when the store's state becomes non-`nil`, and dismisses it when it
    /// becomes `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for an
    ///     alert.
    @available(iOS, introduced: 13, deprecated: 100000, message: "use `View.alert(store:) instead.")
    @available(macOS, introduced: 10.15, deprecated: 100000, message: "use `View.alert(store:) instead.")
    @available(tvOS, introduced: 13, deprecated: 100000, message: "use `View.alert(store:) instead.")
    @available(watchOS, introduced: 6, deprecated: 100000, message: "use `View.alert(store:) instead.")
    @MainActor @preconcurrency public func legacyAlert<ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<SwiftNavigation.AlertState<ButtonAction>>, ComposableArchitecture.PresentationAction<ButtonAction>>) -> some View


    /// Displays a legacy alert when the store's state becomes non-`nil`, and dismisses it when it
    /// becomes `nil`.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for an
    ///     alert.
    ///   - toDestinationState: A transformation to extract alert state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed alert actions into the presentation
    ///     action.
    @available(iOS, introduced: 13, deprecated: 100000, message: "use `View.alert(store:state:action:) instead.")
    @available(macOS, introduced: 10.15, deprecated: 100000, message: "use `View.alert(store:state:action:) instead.")
    @available(tvOS, introduced: 13, deprecated: 100000, message: "use `View.alert(store:state:action:) instead.")
    @available(watchOS, introduced: 6, deprecated: 100000, message: "use `View.alert(store:state:action:) instead.")
    @MainActor @preconcurrency public func legacyAlert<State, Action, ButtonAction>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> SwiftNavigation.AlertState<ButtonAction>?, action fromDestinationAction: @escaping (_ alertAction: ButtonAction) -> Action) -> some View

}

@available(iOS 14, tvOS 14, watchOS 7, *)
@available(macOS, unavailable)
extension View {

    /// Presents a modal view that covers as much of the screen as possible using the store you
    /// provide as a data source for the sheet's content.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's `fullScreenCover` view
    /// > modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a modal. When `store`'s state is non-`nil`, the system passes a store of unwrapped `State`
    ///     and `Action` to the modifier's closure. You use this store to power the content in a sheet
    ///     you create that the system displays to the user. If `store`'s state is `nil`-ed out, the
    ///     system dismisses the currently displayed sheet.
    ///   - onDismiss: The closure to execute when dismissing the modal view.
    ///   - content: A closure returning the content of the modal view.
    @available(iOS, deprecated: 9999, message: "Pass a binding of a store to 'fullScreenCover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(macOS, deprecated: 9999, message: "Pass a binding of a store to 'fullScreenCover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(tvOS, deprecated: 9999, message: "Pass a binding of a store to 'fullScreenCover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(watchOS, deprecated: 9999, message: "Pass a binding of a store to 'fullScreenCover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @MainActor public func fullScreenCover<State, Action, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Content) -> some View where Content : View


    /// Presents a modal view that covers as much of the screen as possible using the store you
    /// provide as a data source for the sheet's content.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's `fullScreenCover` view
    /// > modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a modal. When `store`'s state is non-`nil`, the system passes a store of unwrapped `State`
    ///     and `Action` to the modifier's closure. You use this store to power the content in a sheet
    ///     you create that the system displays to the user. If `store`'s state is `nil`-ed out, the
    ///     system dismisses the currently displayed sheet.
    ///   - toDestinationState: A transformation to extract modal state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed modal actions into the presentation
    ///     action.
    ///   - onDismiss: The closure to execute when dismissing the modal view.
    ///   - content: A closure returning the content of the modal view.
    @available(iOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor public func fullScreenCover<State, Action, DestinationState, DestinationAction, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<DestinationState, DestinationAction>) -> Content) -> some View where Content : View

}

@available(iOS 16, macOS 13, tvOS 16, watchOS 9, *)
extension View {

    /// Associates a destination view with a store that can be used to push the view onto a
    /// `NavigationStack`.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's
    /// > `navigationDestination(isPresented:)` view modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a screen. When `store`'s state is non-`nil`, the system passes a store of unwrapped
    ///     `State` and `Action` to the modifier's closure. You use this store to power the content
    ///     in a view that the system pushes onto the navigation stack. If `store`'s state is
    ///     `nil`-ed out, the system pops the view from the stack.
    ///   - destination: A closure returning the content of the destination view.
    @available(iOS, deprecated: 9999, message: "Pass a binding of a store to 'navigationDestination(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(macOS, deprecated: 9999, message: "Pass a binding of a store to 'navigationDestination(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(tvOS, deprecated: 9999, message: "Pass a binding of a store to 'navigationDestination(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(watchOS, deprecated: 9999, message: "Pass a binding of a store to 'navigationDestination(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @MainActor @preconcurrency public func navigationDestination<State, Action, Destination>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Destination) -> some View where Destination : View


    /// Associates a destination view with a store that can be used to push the view onto a
    /// `NavigationStack`.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's
    /// > `navigationDestination(isPresented:)` view modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a screen. When `store`'s state is non-`nil`, the system passes a store of unwrapped
    ///     `State` and `Action` to the modifier's closure. You use this store to power the content
    ///     in a view that the system pushes onto the navigation stack. If `store`'s state is
    ///     `nil`-ed out, the system pops the view from the stack.
    ///   - toDestinationState: A transformation to extract screen state from the presentation
    ///     state.
    ///   - fromDestinationAction: A transformation to embed screen actions into the presentation
    ///     action.
    ///   - destination: A closure returning the content of the destination view.
    @available(iOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public func navigationDestination<State, Action, DestinationState, DestinationAction, Destination>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, @ViewBuilder destination: @escaping (_ store: ComposableArchitecture.Store<DestinationState, DestinationAction>) -> Destination) -> some View where Destination : View

}

@available(tvOS, unavailable)
@available(watchOS, unavailable)
extension View {

    /// Presents a popover using the given store as a data source for the popover's content.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's `popover` view modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a modal. When `store`'s state is non-`nil`, the system passes a store of unwrapped `State`
    ///     and `Action` to the modifier's closure. You use this store to power the content in a
    ///     popover you create that the system displays to the user. If `store`'s state is `nil`-ed
    ///     out, the system dismisses the currently displayed popover.
    ///   - attachmentAnchor: The positioning anchor that defines the attachment point of the popover.
    ///   - arrowEdge: The edge of the `attachmentAnchor` that defines the location of the popover's
    ///     arrow in macOS. iOS ignores this parameter.
    ///   - content: A closure returning the content of the popover.
    @available(iOS, deprecated: 9999, message: "Pass a binding of a store to 'popover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(macOS, deprecated: 9999, message: "Pass a binding of a store to 'popover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(tvOS, deprecated: 9999, message: "Pass a binding of a store to 'popover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(watchOS, deprecated: 9999, message: "Pass a binding of a store to 'popover(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @MainActor @preconcurrency public func popover<State, Action, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge = .top, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Content) -> some View where Content : View


    /// Presents a popover using the given store as a data source for the popover's content.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's `popover` view modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a modal. When `store`'s state is non-`nil`, the system passes a store of unwrapped `State`
    ///     and `Action` to the modifier's closure. You use this store to power the content in a
    ///     popover you create that the system displays to the user. If `store`'s state is `nil`-ed
    ///     out, the system dismisses the currently displayed popover.
    ///   - toDestinationState: A transformation to extract popover state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed popover actions into the presentation
    ///     action.
    ///   - attachmentAnchor: The positioning anchor that defines the attachment point of the popover.
    ///   - arrowEdge: The edge of the `attachmentAnchor` that defines the location of the popover's
    ///     arrow in macOS. iOS ignores this parameter.
    ///   - content: A closure returning the content of the popover.
    @available(iOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public func popover<State, Action, DestinationState, DestinationAction, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds), arrowEdge: Edge = .top, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<DestinationState, DestinationAction>) -> Content) -> some View where Content : View

}

extension View {

    @MainActor @preconcurrency public func presentation<State, Action, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder body: @escaping (_ content: Self, _ isPresented: Binding<Bool>, _ destination: ComposableArchitecture.DestinationContent<State, Action>) -> Content) -> some View where Content : View


    @MainActor @preconcurrency public func presentation<State, Action, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, @ViewBuilder body: @escaping (_ content: Self, _ item: Binding<ComposableArchitecture.AnyIdentifiable?>, _ destination: ComposableArchitecture.DestinationContent<State, Action>) -> Content) -> some View where Content : View


    @MainActor @preconcurrency public func presentation<State, Action, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, id toID: @escaping (ComposableArchitecture.PresentationState<State>) -> AnyHashable?, @ViewBuilder body: @escaping (_ content: Self, _ item: Binding<ComposableArchitecture.AnyIdentifiable?>, _ destination: ComposableArchitecture.DestinationContent<State, Action>) -> Content) -> some View where Content : View


    @MainActor @preconcurrency public func presentation<State, Action, DestinationState, DestinationAction, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, @ViewBuilder body: @escaping (_ content: Self, _ isPresented: Binding<Bool>, _ destination: ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content) -> some View where Content : View


    @MainActor @preconcurrency public func presentation<State, Action, DestinationState, DestinationAction, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, @ViewBuilder body: @escaping (_ content: Self, _ item: Binding<ComposableArchitecture.AnyIdentifiable?>, _ destination: ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content) -> some View where Content : View


    @ViewBuilder @MainActor @preconcurrency public func presentation<State, Action, DestinationState, DestinationAction, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (State) -> DestinationState?, id toID: @escaping (ComposableArchitecture.PresentationState<State>) -> AnyHashable?, action fromDestinationAction: @escaping (DestinationAction) -> Action, @ViewBuilder body: @escaping (Self, Binding<ComposableArchitecture.AnyIdentifiable?>, ComposableArchitecture.DestinationContent<DestinationState, DestinationAction>) -> Content) -> some View where Content : View

}

extension View {

    /// Presents a sheet using the given store as a data source for the sheet's content.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's `sheet` view modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a modal. When `store`'s state is non-`nil`, the system passes a store of unwrapped `State`
    ///     and `Action` to the modifier's closure. You use this store to power the content in a sheet
    ///     you create that the system displays to the user. If `store`'s state is `nil`-ed out, the
    ///     system dismisses the currently displayed sheet.
    ///   - onDismiss: The closure to execute when dismissing the modal view.
    ///   - content: A closure returning the content of the modal view.
    @available(iOS, deprecated: 9999, message: "Pass a binding of a store to 'sheet(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(macOS, deprecated: 9999, message: "Pass a binding of a store to 'sheet(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(tvOS, deprecated: 9999, message: "Pass a binding of a store to 'sheet(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @available(watchOS, deprecated: 9999, message: "Pass a binding of a store to 'sheet(item:)' instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.7#Replacing-navigation-view-modifiers-with-SwiftUI-modifiers]")
    @MainActor @preconcurrency public func sheet<State, Action, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<State, Action>) -> Content) -> some View where Content : View


    /// Presents a sheet using the given store as a data source for the sheet's content.
    ///
    /// > This is a Composable Architecture-friendly version of SwiftUI's `sheet` view modifier.
    ///
    /// - Parameters:
    ///   - store: A store that is focused on ``PresentationState`` and ``PresentationAction`` for
    ///     a modal. When `store`'s state is non-`nil`, the system passes a store of unwrapped `State`
    ///     and `Action` to the modifier's closure. You use this store to power the content in a sheet
    ///     you create that the system displays to the user. If `store`'s state is `nil`-ed out, the
    ///     system dismisses the currently displayed sheet.
    ///   - toDestinationState: A transformation to extract modal state from the presentation state.
    ///   - fromDestinationAction: A transformation to embed modal actions into the presentation
    ///     action.
    ///   - onDismiss: The closure to execute when dismissing the modal view.
    ///   - content: A closure returning the content of the modal view.
    @available(iOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(macOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(tvOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @available(watchOS, deprecated: 9999, message: "Further scope the store into the 'state' and 'action' cases, instead. For more information, see the following article: https://swiftpackageindex.com/pointfreeco/swift-composable-architecture/main/documentation/composablearchitecture/migratingto1.5#Enum-driven-navigation-APIs")
    @MainActor @preconcurrency public func sheet<State, Action, DestinationState, DestinationAction, Content>(store: ComposableArchitecture.Store<ComposableArchitecture.PresentationState<State>, ComposableArchitecture.PresentationAction<Action>>, state toDestinationState: @escaping (_ state: State) -> DestinationState?, action fromDestinationAction: @escaping (_ destinationAction: DestinationAction) -> Action, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (_ store: ComposableArchitecture.Store<DestinationState, DestinationAction>) -> Content) -> some View where Content : View

}

@available(iOS 13, tvOS 13, *)
@available(macOS, unavailable)
@available(watchOS, unavailable)
extension UIAlertController {

    /// Creates a `UIAlertController` from a ``Store`` focused on alert state.
    ///
    /// You can use this API with the `UIViewController.present(item:)` method:
    ///
    /// ```swift
    /// class FeatureController: UIViewController {
    ///   @UIBindable var store: StoreOf<Feature>
    ///   // ...
    ///
    ///   func viewDidLoad() {
    ///     // ...
    ///
    ///     present(item: $store.scope(state: \.alert, action: \.alert)) { store in
    ///       UIAlertController(store: store)
    ///     }
    ///   }
    /// }
    /// ```
    @MainActor public convenience init<Action>(store: ComposableArchitecture.Store<SwiftNavigation.AlertState<Action>, Action>)

    /// Creates a `UIAlertController` from a ``Store`` focused on confirmation dialog state.
    ///
    /// You can use this API with the `UIViewController.present(item:)` method:
    ///
    /// ```swift
    /// class FeatureController: UIViewController {
    ///   @UIBindable var store: StoreOf<Feature>
    ///   // ...
    ///
    ///   func viewDidLoad() {
    ///     // ...
    ///
    ///     present(item: $store.scope(state: \.dialog, action: \.dialog)) { store in
    ///       UIAlertController(store: store)
    ///     }
    ///   }
    /// }
    /// ```
    @MainActor public convenience init<Action>(store: ComposableArchitecture.Store<SwiftNavigation.ConfirmationDialogState<Action>, Action>)
}

extension NavigationStackController {

    /// Drives a navigation stack controller with a store.
    ///
    /// See the dedicated article on <doc:Navigation> for more information on the library's
    /// navigation tools, and in particular see <doc:StackBasedNavigation> for information on using
    /// this view.
    ///
    /// - Parameters:
    ///   - navigationBarClass: Specify the custom `UINavigationBar` subclass you want to use, or
    ///     specify `nil` to use the standard `UINavigationBar` class.
    ///   - toolbarClass: Specify the custom `UIToolbar` subclass you want to use, or specify `nil`
    ///     to use the standard `UIToolbar` class.
    ///   - path: A binding to a store of stack state.
    ///   - root: A root view controller.
    ///   - destination: A function to create a `UIViewController` from a store.
    ///   - fileID: The source `#fileID` associated with the controller.
    ///   - filePath: The source `#filePath` associated with the controller.
    ///   - line: The source `#line` associated with the controller.
    ///   - column: The source `#column` associated with the controller.
    @MainActor public convenience init<State, Action>(navigationBarClass: AnyClass? = nil, toolbarClass: AnyClass? = nil, path: SwiftNavigation.UIBinding<ComposableArchitecture.Store<ComposableArchitecture.StackState<State>, ComposableArchitecture.StackAction<State, Action>>>, root: () -> UIViewController, destination: @escaping (ComposableArchitecture.Store<State, Action>) -> UIViewController, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)
}

@available(iOS 17, macOS 14, tvOS 17, watchOS 10, *)
@MainActor extension UIPushAction {

    /// Pushes an element of ``StackState`` onto the current navigation stack.
    ///
    /// This is the UIKit equivalent of
    /// ``SwiftUI/NavigationLink/init(state:label:fileID:filePath:line:column:)``.
    ///
    /// - Parameters:
    ///   - state: An element of stack state.
    ///   - fileID: The source `#fileID` associated with the push.
    ///   - filePath: The source `#filePath` associated with the push.
    ///   - line: The source `#line` associated with the push.
    ///   - column: The source `#column` associated with the push.
    @MainActor public func callAsFunction<Element>(state: Element, fileID: StaticString = #fileID, filePath: StaticString = #filePath, line: UInt = #line, column: UInt = #column)
}

public var _cancellationCancellables: ConcurrencyExtras.LockIsolated<ComposableArchitecture.CancellablesCollection>

public let willResignNotificationName: Notification.Name? { get }

public var willEnterForegroundNotificationName: Notification.Name?

public var willTerminateNotificationName: Notification.Name?

public let _isInPerceptionTracking: Bool { get }

